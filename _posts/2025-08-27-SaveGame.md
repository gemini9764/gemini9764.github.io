---
title: SaveGame
description: 세이브와 데이터 퍼시스턴스
author: gemini
date: 2025-08-27 20:00:00 +09:00
categories: [Unreal]
tags: [SaveGame]
math: true
mermaid: true
---

#### SaveGame의 기본 개념과 메모리의 특성 이해하기

##### 메모리의 치명적 약점

- RAM(메모리)의 특성
	- 모든 게임 데이터가 RAM에 저장됨
	- 휘발성 (Volatile) : 전원이 꺼지면 모든 데이터가 사라짐

```
int PlayerLevel = 15;
float PlayerHealth = 100.0f;
// 게임 종료 시 완전히 사라짐!
```

- 영구 저장소 (Persistent Storage)가 필요한 경우
	- 하드디스크 / SSD에 저장해야만 데이터가 살아남음


##### 파일에 텍스트로 저장하면 안되나?

- 첫 번째 문제 : 플랫폼 차이
	- PC : `C:\Users\YourName\Documents\`
	- PlayStation, Xbox, Switch : 각각 다른 저장 위치와 방식

- 두 번째 문제 : 데이터 타입 변환 복잡성

```
FVector PlayerLocation = FVector(123.456f, 789.012f, 456.789f);

// 텍스트 저장할 때 이렇게 바꿈
// PlayerX=123.456
// PlayerY=789.012
// PlayerZ=456.789

// 불러올 때
FString XString = "123.456";
float X = FCString::Atof(*XString);  // 매번 변환 필요!
```

- 세 번째 문제 : 복잡한 데이터 구조

```
struct FInventoryItem
{
    FString ItemName;
    int32 ItemCount;
    float ItemDurability;
    TArray<FString> ItemOptions;
};

TArray<FInventoryItem> PlayerInventory;  // 100개의 아이템
```

- 네 번째 문제 : 보안과 치팅

```
PlayerLevel=999999
PlayerGold=999999999 // 누구나 메모장으로 수정 가능
```


##### 언리얼의 SaveGame 시스템이 해결해주는 것

1. 플랫폼 자동 대응
	- Windows, Mac, PlayStation, Xbox 등 자동 처리
2. 자동 직렬화
	- 복잡한 객체를 파일로 저장 가능한 형태로 자동 변환
3. 타입 안정성
	- C++ 의 강력한 타입 시스템 그대로 활용
4. 바이너리 저장
	- 일반 사용자가 쉽게 수정할 수 없음


##### SaveGame 클래스의 핵심 개념

- 필수 요소들
	1. `USaveGame`을 상속받아야 함
	2. `UCLASS()` 매크로 필요
	3. 저장할 변수에는 `UPROPERTY()` 매크로 필요

- SaveGame 클래스 예시

```
// MySaveGame.h
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/SaveGame.h"
#include "MySaveGame.generated.h"

UCLASS()
class MYGAME_API UMySaveGame : public USaveGame
{
    GENERATED_BODY()

public:
    UMySaveGame();

    // 저장할 플레이어 데이터들
    UPROPERTY(VisibleAnywhere, Category = "SaveData")
    FString PlayerName;

    UPROPERTY(VisibleAnywhere, Category = "SaveData")
    int32 PlayerLevel;

    UPROPERTY(VisibleAnywhere, Category = "SaveData")
    float PlayerHealth;

    UPROPERTY(VisibleAnywhere, Category = "SaveData")
    FVector PlayerLocation;

    // 세이브 슬롯 정보
    UPROPERTY(VisibleAnywhere, Category = "SaveData")
    FString SaveSlotName;

    UPROPERTY(VisibleAnywhere, Category = "SaveData")
    uint32 UserIndex;
};

```

- 매크로 역할
	- **UCLASS()** : 언리얼 리플렉션 시스템에 클래스 등록
	- **UPROPERTY()** : 변수를 언리얼이 관리하게 만듦
	- ***UPROPERTY()가 없으면 저장되지 않음!***

- 내부 매커니즘
	- 컴파일 시점
		- Unreal Header Tool(UHT)이 `UCLASS()`와 `UPROPERTY()` 매크로를 발견
		- 자동으로 `.gnerated.h` 파일 생성 (리플렉션 정보 담김)

- 런타임 동작

	```
	UGameplayStatics::SaveGameToSlot(SaveGameInstance, TEXT("MySlot"), 0);
	```

	- SaveGame 객체 생성 -> 리플렉션 시스템이 UPROPERTY 변수들 확인
	- 저장 시 : 변수들을 바이너리 데이터로 변환 (직렬화)
	- 플랫폼에 맞는 위치에 자동 저장


#### SaveGame 객체 생성과 저장 매커니즘

##### SaveGame 객체를 생성하는 올바른 방법

- 잘못된 방법

```
UMySaveGame* SaveGame = new UMySaveGame();  // 절대 금지!
```

- 올바른 방법

```
void AMyPlayerController::SaveGame()
{
    // 1단계: SaveGame 객체를 올바른 방법으로 생성
    UMySaveGame* SaveGameInstance = Cast<UMySaveGame>(
        UGameplayStatics::CreateSaveGameObject(UMySaveGame::StaticClass())
    );

    // 생성 실패 체크 (방어적 프로그래밍)
    if (!SaveGameInstance)
    {
        UE_LOG(LogTemp, Error, TEXT("세이브 객체 생성에 실패했습니다!"));
        return;
    }
}
```

- CreateSaveGameObject()가 하는 일
	- 언리얼의 가비지 컬렉션 시스템에 등록
	- 안전한 메모리 관리
	- 플랫폼별 최적화 적용


##### 현재 게임 데이터를 SaveGame에 복사하기

```
// 2단계: 현재 게임의 데이터를 SaveGame 객체에 복사
AMyCharacter* MyCharacter = Cast<AMyCharacter>(GetPawn());
if (MyCharacter)
{
    // 플레이어 정보를 하나씩 복사
    SaveGameInstance->PlayerName = MyCharacter->GetPlayerName();
    SaveGameInstance->PlayerLevel = MyCharacter->GetLevel();
    SaveGameInstance->PlayerHealth = MyCharacter->GetHealth();
    SaveGameInstance->PlayerLocation = MyCharacter->GetActorLocation();

    UE_LOG(LogTemp, Warning, TEXT("플레이어 데이터 복사 완료: %s, 레벨 %d"),
           *SaveGameInstance->PlayerName, SaveGameInstance->PlayerLevel);
}
else
{
    UE_LOG(LogTemp, Error, TEXT("플레이어 캐릭터를 찾을 수 없습니다!"));
    return;
}
```

- 데이터 복사 방식
	- 복사 : 완전히 독립적인 데이터 생성
	- 참조 아님 : 원본이 사라져도 SaveGame 데이터는 안전


##### 세이브 슬롯 정보 설정

```
// 3단계: 세이브 슬롯 정보를 설정
SaveGameInstance->SaveSlotName = TEXT("MyGameSave");
SaveGameInstance->UserIndex = 0;
```

- 슬롯 정보
	- **SaveSlotName** : 실제 파일명의 기준 (`MyGameSave.sav`)
	- **UserIndex** : 사용자 구분 (보통 0, 멀티플레이어에서는 각자 다른 번호)


##### 실제 파일 저장과 내부 동작 메커니즘

```
// 4단계: 실제로 파일에 저장
bool bSaveSuccess = UGameplayStatics::SaveGameToSlot(
    SaveGameInstance,                    // 저장할 SaveGame 객체
    SaveGameInstance->SaveSlotName,      // 파일 이름
    SaveGameInstance->UserIndex          // 사용자 인덱스
);

// 5단계: 저장 결과 확인
if (bSaveSuccess)
{
    UE_LOG(LogTemp, Warning, TEXT("게임 저장 성공: %s"), *SaveGameInstance->SaveSlotName);
}
else
{
    UE_LOG(LogTemp, Error, TEXT("게임 저장 실패!"));
}
```

- SaveGameToSlot()이 내부에서 하는 일
	1. SaveGameInstance 객체 들여다봄. 리플렉션을 통한 저장할 목록 조사
	2. SaveGameInstance 안에 들어 있는 현재 값들 추출함
	3. 직렬화 (Serialization) 수행
	4. 플랫폼별 저장 위치 결정
	5. 파일 쓰기 작업
	6. 결과 반환

- 저장된 파일의 실제 모습 (.sav)

```
00 00 00 00 4D 79 53 61 76 65 47 61 6D 65 00 00
05 00 00 00 ED 99 8D EA B8 B8 EB 8F 99 0F 00 00
00 42 C8 00 00 00 00 80 3F 00 00 00 40 00 00 40 40
```


##### 완전한 저장 함수

```
void AMyPlayerController::SaveGame()
{
    UE_LOG(LogTemp, Warning, TEXT("게임 저장을 시작합니다..."));

    // 1단계: SaveGame 객체 생성
    UMySaveGame* SaveGameInstance = Cast<UMySaveGame>(
        UGameplayStatics::CreateSaveGameObject(UMySaveGame::StaticClass())
    );

    if (!SaveGameInstance)
    {
        UE_LOG(LogTemp, Error, TEXT("SaveGame 객체 생성 실패"));
        return;
    }

    // 2단계: 플레이어 데이터 수집
    AMyCharacter* MyCharacter = Cast<AMyCharacter>(GetPawn());
    if (!MyCharacter)
    {
        UE_LOG(LogTemp, Error, TEXT("플레이어 캐릭터를 찾을 수 없음"));
        return;
    }

    // 3단계: 데이터 복사
    SaveGameInstance->PlayerName = MyCharacter->GetPlayerName();
    SaveGameInstance->PlayerLevel = MyCharacter->GetLevel();
    SaveGameInstance->PlayerHealth = MyCharacter->GetHealth();
    SaveGameInstance->PlayerLocation = MyCharacter->GetActorLocation();

    // 4단계: 세이브 정보 설정
    SaveGameInstance->SaveSlotName = TEXT("PlayerSave");
    SaveGameInstance->UserIndex = 0;

    // 5단계: 실제 저장
    bool bSaveSuccess = UGameplayStatics::SaveGameToSlot(
        SaveGameInstance,
        SaveGameInstance->SaveSlotName,
        SaveGameInstance->UserIndex
    );

    // 6단계: 결과 처리
    if (bSaveSuccess)
    {
        UE_LOG(LogTemp, Warning, TEXT("게임 저장 완료! 위치: %s"),
               *SaveGameInstance->PlayerLocation.ToString());
    }
    else
    {
        UE_LOG(LogTemp, Error, TEXT("게임 저장 실패!"));
    }
}
```


#### SaveGame 불러오기 매커니즘

##### 파일 존재 확인의 중요성

- 확인해야 하는 이유
	- 존재하지 않는 파일을 불러오면 `nullptr` 반환 또는 크래시
	- 첫 플레이 시에는 세이브 파일이 없음

- 올바른 방법 : DoesSaveGameExist()

```
void AMyPlayerController::LoadGame()
{
    // 1단계: 세이브 파일 정보 설정
    FString SlotName = TEXT("PlayerSave");
    uint32 UserIndex = 0;

    UE_LOG(LogTemp, Warning, TEXT("게임 불러오기 시도: %s"), *SlotName);

    // 2단계: 파일 존재 확인 (필수!)
    if (!UGameplayStatics::DoesSaveGameExist(SlotName, UserIndex))
    {
        UE_LOG(LogTemp, Warning, TEXT("세이브 파일이 존재하지 않습니다: %s"), *SlotName);

        // 첫 플레이인 경우 기본값으로 게임 시작
        InitializeNewGame();
        return;
    }

    UE_LOG(LogTemp, Warning, TEXT("세이브 파일 발견됨, 불러오기 진행"));
}
```

- 첫 게임 실행 시 : 새 게임 초기화

```
void AMyPlayerController::InitializeNewGame()
{
    UE_LOG(LogTemp, Warning, TEXT("새 게임으로 시작합니다"));

    AMyCharacter* MyCharacter = Cast<AMyCharacter>(GetPawn());
    if (MyCharacter)
    {
        MyCharacter->SetPlayerName(TEXT("새로운 플레이어"));
        MyCharacter->SetLevel(1);
        MyCharacter->SetHealth(100.0f);
    }
}
```


##### 파일 불러오기와 역직렬화 과정

```
// 3단계: 세이브 파일을 메모리로 불러오기
USaveGame* LoadedGame = UGameplayStatics::LoadGameFromSlot(SlotName, UserIndex);

if (!LoadedGame)
{
    UE_LOG(LogTemp, Error, TEXT("세이브 파일을 읽는 중 오류 발생!"));
    HandleCorruptedSave();
    return;
}

UE_LOG(LogTemp, Warning, TEXT("세이브 파일 읽기 성공"));
```

- LoadGameFromSlot()의 내부 동작
	1. **파일 읽기**
		- 바이너리 데이터를 메모리로 로드
	2. **헤더 정보 확인**
		- 언리얼 버전, SaveGame 클래스 정보 등
	3. **클래스 타입 확인**
		- 호환성 검사
	4. **역직렬화**
		- 바이너리 -> 객체로 변환


##### 안전한 타입 변환과 검증

```
// 4단계: 올바른 타입으로 변환
UMySaveGame* LoadedSaveGame = Cast<UMySaveGame>(LoadedGame);

if (!LoadedSaveGame)
{
    UE_LOG(LogTemp, Error, TEXT("세이브 파일 타입이 올바르지 않습니다!"));
    HandleIncompatibleSave();
    return;
}

UE_LOG(LogTemp, Warning, TEXT("세이브 데이터 타입 확인 완료"));
```

- Cast가 실패하는 경우
	- 다른 게임의 세이브 파일
	- 게임 업데이트로 SaveGame 클래스가 변경됨
	- 파일 손상
	- 악의적으로 변조된 파일


##### 데이터 검증과 안전성 확보

```
// 5단계: 불러온 데이터의 유효성 검증
bool bIsDataValid = ValidateSaveData(LoadedSaveGame);
if (!bIsDataValid)
{
    UE_LOG(LogTemp, Error, TEXT("세이브 데이터가 유효하지 않습니다!"));
    InitializeNewGame();
    return;
}
```

- ValidateSaveData() 함수

```
bool AMyPlayerController::ValidateSaveData(UMySaveGame* SaveData)
{
    if (!SaveData)
    {
        UE_LOG(LogTemp, Error, TEXT("SaveData가 null입니다"));
        return false;
    }

    // 플레이어 레벨 검증
    if (SaveData->PlayerLevel < 1 || SaveData->PlayerLevel > 1000)
    {
        UE_LOG(LogTemp, Error, TEXT("플레이어 레벨이 비정상적입니다: %d"), SaveData->PlayerLevel);
        return false;
    }

    // 플레이어 체력 검증
    if (SaveData->PlayerHealth < 0.0f || SaveData->PlayerHealth > 999.0f)
    {
        UE_LOG(LogTemp, Error, TEXT("플레이어 체력이 비정상적입니다: %f"), SaveData->PlayerHealth);
        return false;
    }

    // 플레이어 이름 검증
    if (SaveData->PlayerName.IsEmpty() || SaveData->PlayerName.Len() > 50)
    {
        UE_LOG(LogTemp, Error, TEXT("플레이어 이름이 비정상적입니다"));
        return false;
    }

    // 위치 검증 (맵 경계 내에 있는지)
    FVector Location = SaveData->PlayerLocation;
    if (FMath::Abs(Location.X) > 100000.0f ||
        FMath::Abs(Location.Y) > 100000.0f ||
        Location.Z < -10000.0f || Location.Z > 10000.0f)
    {
        UE_LOG(LogTemp, Warning, TEXT("플레이어 위치가 맵 경계를 벗어남"));
        SaveData->PlayerLocation = FVector(0, 0, 100);
    }

    return true;
}
```


##### 게임 상태에서 데이터 적용하기

```
// 6단계: 검증된 데이터를 현재 게임에 적용
ApplySaveDataToGame(LoadedSaveGame);
```

- ApplySaveDataToGame() 함수

```
void AMyPlayerController::ApplySaveDataToGame(UMySaveGame* SaveData)
{
    AMyCharacter* MyCharacter = Cast<AMyCharacter>(GetPawn());
    if (!MyCharacter)
    {
        UE_LOG(LogTemp, Error, TEXT("플레이어 캐릭터를 찾을 수 없습니다"));
        return;
    }

    // 플레이어 정보 복원
    MyCharacter->SetPlayerName(SaveData->PlayerName);
    MyCharacter->SetLevel(SaveData->PlayerLevel);
    MyCharacter->SetHealth(SaveData->PlayerHealth);

    // 플레이어 위치 복원
    RestorePlayerLocation(SaveData->PlayerLocation);
}

void AMyPlayerController::RestorePlayerLocation(const FVector& SavedLocation)
{
    AMyCharacter* MyCharacter = Cast<AMyCharacter>(GetPawn());
    if (!MyCharacter) return;

    // 안전한 스폰을 위해 Z값 조정
    FVector SpawnLocation = SavedLocation;
    SpawnLocation.Z += 100.0f;

    MyCharacter->SetActorLocation(SpawnLocation);

    UE_LOG(LogTemp, Warning, TEXT("플레이어 위치 복원 완료: %s"),
           *SpawnLocation.ToString());
}
```


##### 완전한 불러오기 함수

```
void AMyPlayerController::LoadGame()
{
    UE_LOG(LogTemp, Warning, TEXT("=== 게임 불러오기 시작 ==="));

    FString SlotName = TEXT("PlayerSave");
    uint32 UserIndex = 0;

    // 1단계: 파일 존재 확인
    if (!UGameplayStatics::DoesSaveGameExist(SlotName, UserIndex))
    {
        UE_LOG(LogTemp, Warning, TEXT("세이브 파일이 없습니다. 새 게임을 시작합니다."));
        InitializeNewGame();
        return;
    }

    // 2단계: 파일 읽기
    USaveGame* LoadedGame = UGameplayStatics::LoadGameFromSlot(SlotName, UserIndex);
    if (!LoadedGame)
    {
        UE_LOG(LogTemp, Error, TEXT("세이브 파일 읽기 실패"));
        HandleCorruptedSave();
        return;
    }

    // 3단계: 타입 변환
    UMySaveGame* LoadedSaveGame = Cast<UMySaveGame>(LoadedGame);
    if (!LoadedSaveGame)
    {
        UE_LOG(LogTemp, Error, TEXT("세이브 파일 타입 불일치"));
        HandleIncompatibleSave();
        return;
    }

    // 4단계: 데이터 검증
    if (!ValidateSaveData(LoadedSaveGame))
    {
        UE_LOG(LogTemp, Error, TEXT("세이브 데이터 검증 실패"));
        InitializeNewGame();
        return;
    }

    // 5단계: 게임에 적용
    ApplySaveDataToGame(LoadedSaveGame);

    UE_LOG(LogTemp, Warning, TEXT("=== 게임 불러오기 완료 ==="));
}
```


#### 직렬화 (Serialization)의 깊은 이해

##### 직렬화란
- 메모리의 복잡한 구조 -> 파일의 일렬된 구조로 변환
- **직렬화** : 복잡한 구조를 일렬로 변환
	- `int32 15` -> `0F 00 00 00` (4바이트)
	- `float 87.5` -> `00 00 AF 42` (4바이트)
	- `FString "홍길동"` -> 길이 정보 + UTF-8 문자 데이터
- **역직렬화** : 일렬된 데이터를 복잡한 구조로 복원


##### 메모리 vs 파일 - 변환이 필요한 이유

- 메모리 구조

```
FVector PlayerLocation(100.0f, 200.0f, 50.0f);

// 메모리에서:
주소 0x12345678: 100.0f  (X값)
주소 0x1234567C: 200.0f  (Y값)
주소 0x12345680: 50.0f   (Z값)
```

- 파일 구조

```
파일 = 일렬로 늘어선 바이트들
[바이트1] [바이트2] [바이트3] [바이트4] ...
```

- 문제점
	- 메모리 주소를 저장해봤자 게임 재시작 시 무의미
	- 실제 값을 순서대로 저장해야 함


#### 언리얼 엔진의 직렬화 - UPROPERTY

```
UCLASS()
class UPlayerSaveData : public USaveGame
{
    GENERATED_BODY()

public:
    UPROPERTY()
    int32 PlayerLevel;    // 4바이트

    UPROPERTY()
    float PlayerHealth;   // 4바이트

    UPROPERTY()
    FString PlayerName;   // 가변 크기
};
```

- 컴파일 시점에서 일어나는 일
	1. Unreal Header Tool(UHT) 코드 분석
	2. `UPROPERTY()` 변수들 찾기
	3. 자동으로 직렬화 코드 생성

```
// 언리얼이 자동으로 만들어주는 코드 (개념 예시)
void UPlayerSaveData::AutoGeneratedSerialize(FArchive& Ar)
{
    Ar << PlayerLevel;   // int32 → 4바이트
    Ar << PlayerHealth;  // float → 4바이트

    // FString은 길이 + 문자 데이터로 저장
    int32 NameLength = PlayerName.Len();
    Ar << NameLength;
    for (int32 i = 0; i < NameLength; i++)
    {
        Ar << PlayerName[i];
    }
}
```

- 런타임에서 일어나는 일
	1. 리플렉션 정보 확인
	2. 각 타입에 맞는 직렬화 적용
	3. 바이너리 데이터로 변환
	4. 파일에 저장


##### 실제 바이너리 데이터로의 변화

```
// 예시 데이터:
SaveData->PlayerLevel = 25;           // 정수
SaveData->PlayerHealth = 87.5f;       // 실수
SaveData->PlayerName = TEXT("김철수"); // 문자열
```

- 변환 과정

1. PlayerLevel (int32) -> 바이너리

```
25 → 이진법: 00000000 00000000 00000000 00011001
   → 16진법: 0x00000019
   → 파일저장: 19 00 00 00 (리틀 엔디안)
```

2. PlayerHealth (float) -> 바이너리

```
87.5f → IEEE 754: 01000010101011110000000000000000
      → 16진법: 0x42AF0000
      → 파일저장: 00 00 AF 42
```

3. PlayerName (FString) -> 바이너리

```
"홍길동" → 길이 저장: 03 00 00 00
        → UTF-8 인코딩:
		    - '홍' → `ED 99 8D`
				- '길' → `EA B8 B8`
				- '동' → `EB 8F 99`
        → 널 종료자: 00
        
        
03 00 00 00 ED 99 8D EA B8 B8 EB 8F 99 00
```

- 최종 파일

```
19 00 00 00                           (PlayerLevel: 4바이트)
00 00 AF 42                           (PlayerHealth: 4바이트)
03 00 00 00 ED 99 8D EA B8 B8 EB 8F 99 00  (PlayerName: 13바이트)
총 21바이트
```


##### 복잡한 데이터 타입들

- TArray\<int32\> 저장

```
UPROPERTY()
TArray<int32> CompletedLevels;

CompletedLevels.Add(1);
CompletedLevels.Add(5);
CompletedLevels.Add(10);
// 데이터: [1, 5, 10]
```

- 저장 과정

```
1. 배열 크기 저장: 03 00 00 00    (3개)
2. 첫 번째 원소: 01 00 00 00     (1)
3. 두 번째 원소: 05 00 00 00     (5)
4. 세 번째 원소: 0A 00 00 00     (10)

03 00 00 00   01 00 00 00   05 00 00 00   0A 00 00 00
    ↑크기(3)       ↑첫 원소        ↑두 번째       ↑세 번째
```

- TMap\<FString, int32\> 저장

```
UPROPERTY()
TMap<FString, int32> ItemCounts;

ItemCounts.Add(TEXT("포션"), 5);
ItemCounts.Add(TEXT("화살"), 50);
// 데이터: {"포션": 5, "화살": 50}
```

- 저장 과정

```
1. 맵 크기 저장: 02 00 00 00      (2개 쌍)
2. 첫 번째 쌍:
   - 키 "포션": [길이] + [UTF-8 데이터]
   - 값 5: 05 00 00 00
3. 두 번째 쌍:
   - 키 "화살": [길이] + [UTF-8 데이터]
   - 값 50: 32 00 00 00
   
02 00 00 00
[키 "포션" 데이터] 05 00 00 00
[키 "화살" 데이터] 32 00 00 00
```


##### 커스텀 구조체 

```
USTRUCT(BlueprintType)
struct FInventoryItem
{
    GENERATED_BODY()

    UPROPERTY()
    FString ItemName;

    UPROPERTY()
    int32 Quantity;

    UPROPERTY()
    float Durability;

    // 기본 생성자 필수!
    FInventoryItem()
    {
        ItemName = TEXT("");
        Quantity = 0;
        Durability = 100.0f;
    }
};
```

- 필수 요소들
	1. **USTRUCT()** 매크로
	2. **GENERATED_BODY()** 매크로
	3. **모든 멤버에 UPROPERTY()**
	4. **기본 생성자**


##### 저장되지 않는 것들과 해결 방법

- 문제가 되는 코드

```
UCLASS()
class UProblematicSaveGame : public USaveGame
{
    GENERATED_BODY()

public:
    // 포인터들 - 저장되지 않음!
    UPROPERTY()
    AActor* MyActor;

    UPROPERTY()
    UTexture2D* PlayerAvatar;

    // 엔진 내부 타입들
    UPROPERTY()
    FTimerHandle TimerHandle;
};

```

- 올바른 해결 방법 : 주소 대신 "식별 정보" 저장

```
UCLASS()
class UCorrectSaveGame : public USaveGame
{
    GENERATED_BODY()

public:
    // 포인터 대신 식별 정보 저장
    UPROPERTY()
    FString ActorName;        // 액터 이름

    UPROPERTY()
    FGuid ActorGUID;          // 고유 식별자

    UPROPERTY()
    FString TexturePath;      // 텍스처 경로

    // 핸들 대신 상태 정보 저장
    UPROPERTY()
    float TimerRemainingTime;

    UPROPERTY()
    bool bTimerIsActive;
};
```

- 저장할 때 (Actor -> 이름 / ID로 변환)

```
void SaveActorReference(AActor* ActorToSave)
{
    if (ActorToSave)
    {
        // 주소 대신 이름 저장
        MySaveGame->ActorName = ActorToSave->GetName();
        
        // 고유 ID가 있으면 같이 저장
        if (ActorToSave->GetUniqueID().IsValid())
        {
            MySaveGame->ActorGUID = ActorToSave->GetUniqueID();
        }
    }
}
```

- 불러올 때 (저장된 단서 -> Actor 다시 찾기)

```
AActor* FindSavedActor()
{
    for (TActorIterator<AActor> ActorItr(GetWorld()); ActorItr; ++ActorItr)
    {
        AActor* Actor = *ActorItr;
        if (Actor->GetName() == MySaveGame->ActorName)
        {
            return Actor;  // 찾았다!
        }
    }
    
    UE_LOG(LogTemp, Warning, TEXT("저장된 액터를 찾을 수 없습니다: %s"), 
           *MySaveGame->ActorName);
    return nullptr;
}
```


#### JSON vs Binary

##### JSON vs Binary

- 저장할 데이터

```
FString PlayerName = TEXT("김철수");
int32 Level = 25;
float Health = 87.5f;
FVector Position = FVector(1250.0f, -500.0f, 128.0f);
```

- 바이너리 방식 (.sav)

```
4D 79 53 61 76 65 47 61 6D 65 00 00 05 00 00 00
ED 99 8D EA B8 B8 EB 8F 99 00 19 00 00 00 00 00
AF 42 00 00 9C 44 00 00 F0 C3 00 00 00 43
```

- JSON 방식 (.json)

```
{
    "PlayerName": "김철수",
    "Level": 25,
    "Health": 87.5,
    "Position": {
        "X": 1250.0,
        "Y": -500.0,
        "Z": 128.0
    }
}
```

*사람이 읽을 수 있는 텍스트*


##### 각 방식의 장단점

- 바이너리 (.sav) 
	- 장점
		- **파일 크기 작음** : JSON의 1/3 수준
		- **속도 빠름** : 직접 메모리 복사
		- **보안성 높음** : 일반 사용자가 수정하기 어려움

	- 단점
		- **디버깅 어려움** : 내용을 확인하기 어려움
		- **다른 시스템과 호환 어려움** : 언리얼 전용 포맷
		- **버전 관리 복잡** : 구조 변경 시 호환성 문제

- JSON (.json)
	- 장점
		- **사람이 읽을 수 있음** : 메모장으로 확인 가능
		- **디버깅 쉬움** : 문제 발견이 용이
		- **웹과 연동 쉬움** : 모든 언어에서 지원
		- **설정 파일에 적합** : 사용자나 개발자가 직접 수정 가능

	- 단점
		- **파일 크기 큼** : 2~3배 더 많은 공간 필요
		- **속도 느림** : 텍스트 파싱 과정 필요
		- **보안 취약** : 누구나 쉽게 수정 가능


##### 언제 어떤 방식을 사용할까

- 바이너리 (.sav)를 사용해야 하는 경우
	- 플레이어 진행상황 저장
		- 플레이어 레벨, 경험치, 능력치
		- 인벤토리 아이템들
		- 퀘스트 진행상황
		- 게임 설정값 (민감한 것들)
	- 자주 저장/로드되는 데이터
		- 오토세이브, 퀵세이브
		- 속도가 중요한 경우

- JSON (.json)을 사용해야 하는 경우
1. 설정 파일들

```
// GameSettings.json
{
    "Graphics": {
        "Resolution": "1920x1080",
        "Quality": "High",
        "VSync": true
    },
    "Audio": {
        "MasterVolume": 0.8,
        "SFXVolume": 0.6,
        "MusicVolume": 0.7
    }
}
```

2. 개발 단계의 데이터

```
// 레벨 디자이너가 수정할 수 있는 데이터
{
    "Enemies": [
        {"Type": "Goblin", "Count": 5, "Level": 3},
        {"Type": "Orc", "Count": 2, "Level": 8}
    ],
    "Rewards": {
        "Gold": 100,
        "Experience": 50
    }
}
```

3. 웹 연동이 필요한 데이터
	- 리더보드
	- 친구 목록
	- 웹서버와 주고받는 데이터


##### JSON 사용 예시 코드

- 필요한 헤더 파일

```
// JsonSaveSystem.h
#include "CoreMinimal.h"
#include "Engine/GameInstance.h"
#include "Dom/JsonObject.h"
#include "Serialization/JsonSerializer.h"
#include "Serialization/JsonWriter.h"
#include "HAL/PlatformFileManager.h"
```

- JSON 저장 함수

```
bool UJsonSaveSystem::SavePlayerDataToJson(const FString& SlotName)
{
    UE_LOG(LogTemp, Warning, TEXT("JSON 저장을 시작합니다: %s"), *SlotName);

    // 1단계: 현재 플레이어 찾기
    AMyCharacter* Player = GetCurrentPlayer();
    if (!Player)
    {
        UE_LOG(LogTemp, Error, TEXT("플레이어를 찾을 수 없습니다!"));
        return false;
    }

    // 2단계: JSON 루트 객체 만들기
    TSharedPtr<FJsonObject> RootObject = MakeShareable(new FJsonObject);

    // 3단계: 기본 데이터를 JSON에 추가
    RootObject->SetStringField(TEXT("PlayerName"), Player->GetPlayerName());
    RootObject->SetNumberField(TEXT("Level"), Player->GetLevel());
    RootObject->SetNumberField(TEXT("Health"), Player->GetHealth());

    // 4단계: 복잡한 구조체 데이터 추가 (FVector)
    FVector PlayerPos = Player->GetActorLocation();
    TSharedPtr<FJsonObject> PositionObject = MakeShareable(new FJsonObject);
    PositionObject->SetNumberField(TEXT("X"), PlayerPos.X);
    PositionObject->SetNumberField(TEXT("Y"), PlayerPos.Y);
    PositionObject->SetNumberField(TEXT("Z"), PlayerPos.Z);
    RootObject->SetObjectField(TEXT("Position"), PositionObject);

    // 5단계: 배열 데이터 추가
    TArray<FString> CompletedQuests = Player->GetCompletedQuests();
    TArray<TSharedPtr<FJsonValue>> QuestArray;

    for (const FString& QuestName : CompletedQuests)
    {
        TSharedPtr<FJsonValue> QuestValue = MakeShareable(new FJsonValueString(QuestName));
        QuestArray.Add(QuestValue);
    }
    RootObject->SetArrayField(TEXT("CompletedQuests"), QuestArray);

    // 6단계: JSON을 텍스트로 변환
    FString OutputString;
    TSharedRef<TJsonWriter<>> Writer = TJsonWriterFactory<>::Create(&OutputString);
    bool bSerializeSuccess = FJsonSerializer::Serialize(RootObject.ToSharedRef(), Writer);

    if (!bSerializeSuccess)
    {
        UE_LOG(LogTemp, Error, TEXT("JSON 텍스트 변환 실패"));
        return false;
    }

    // 7단계: 파일 경로 만들기
    FString SavePath = FPaths::ProjectSavedDir() / TEXT("SaveGames") / SlotName + TEXT(".json");

    // 8단계: 디렉토리 생성
    FString Directory = FPaths::GetPath(SavePath);
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();

    if (!PlatformFile.DirectoryExists(*Directory))
    {
        PlatformFile.CreateDirectoryTree(*Directory);
    }

    // 9단계: 파일에 저장
    bool bSaveSuccess = FFileHelper::SaveStringToFile(OutputString, *SavePath);

    if (bSaveSuccess)
    {
        UE_LOG(LogTemp, Warning, TEXT("JSON 저장 완료: %s"), *SavePath);
    }

    return bSaveSuccess;
}
```


##### JSON 불러오기

```
bool UJsonSaveSystem::LoadPlayerDataFromJson(const FString& SlotName)
{
    // 1단계: 파일 경로 만들기
    FString LoadPath = FPaths::ProjectSavedDir() / TEXT("SaveGames") / SlotName + TEXT(".json");

    // 2단계: 파일 존재 확인
    IPlatformFile& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();
    if (!PlatformFile.FileExists(*LoadPath))
    {
        UE_LOG(LogTemp, Error, TEXT("JSON 파일이 없습니다: %s"), *LoadPath);
        return false;
    }

    // 3단계: 파일을 텍스트로 읽기
    FString JsonString;
    if (!FFileHelper::LoadFileToString(JsonString, *LoadPath))
    {
        UE_LOG(LogTemp, Error, TEXT("파일 읽기 실패"));
        return false;
    }

    // 4단계: 텍스트를 JSON 객체로 파싱
    TSharedPtr<FJsonObject> JsonObject;
    TSharedRef<TJsonReader<>> Reader = TJsonReaderFactory<>::Create(JsonString);

    if (!FJsonSerializer::Deserialize(Reader, JsonObject) || !JsonObject.IsValid())
    {
        UE_LOG(LogTemp, Error, TEXT("JSON 파싱 실패"));
        return false;
    }

    // 5단계: 데이터 안전하게 읽기
    FString PlayerName;
    if (JsonObject->TryGetStringField(TEXT("PlayerName"), PlayerName))
    {
        UE_LOG(LogTemp, Warning, TEXT("플레이어 이름: %s"), *PlayerName);
    }

    int32 Level = 1;
    double LevelDouble;
    if (JsonObject->TryGetNumberField(TEXT("Level"), LevelDouble))
    {
        Level = static_cast<int32>(LevelDouble);
    }

    float Health = 100.0f;
    double HealthDouble;
    if (JsonObject->TryGetNumberField(TEXT("Health"), HealthDouble))
    {
        Health = static_cast<float>(HealthDouble);
    }

    // 6단계: 중첩 객체 읽기 (Position)
    const TSharedPtr<FJsonObject>* PositionObject = nullptr;
    if (JsonObject->TryGetObjectField(TEXT("Position"), PositionObject) &&
        PositionObject->IsValid())
    {
        double X = 0.0, Y = 0.0, Z = 0.0;
        (*PositionObject)->TryGetNumberField(TEXT("X"), X);
        (*PositionObject)->TryGetNumberField(TEXT("Y"), Y);
        (*PositionObject)->TryGetNumberField(TEXT("Z"), Z);

        FVector LoadedPosition(static_cast<float>(X), static_cast<float>(Y), static_cast<float>(Z));
        UE_LOG(LogTemp, Warning, TEXT("플레이어 위치: %s"), *LoadedPosition.ToString());
    }

    // 7단계: 배열 읽기 (CompletedQuests)
    const TArray<TSharedPtr<FJsonValue>>* QuestArray = nullptr;
    if (JsonObject->TryGetArrayField(TEXT("CompletedQuests"), QuestArray))
    {
        for (const TSharedPtr<FJsonValue>& QuestValue : *QuestArray)
        {
            FString QuestName;
            if (QuestValue->TryGetString(QuestName))
            {
                UE_LOG(LogTemp, Log, TEXT("완료된 퀘스트: %s"), *QuestName);
            }
        }
    }

    return true;
}
```


#### 핵심 요약

- SaveGeme 시스템의 핵심
	1. `UPROPERTY()` 매크로가 붙은 변수만 저장됨
	2. 언리얼이 플랫폼별 차이를 자동 처리
	3. 바이너리 형태로 안전한고 효율적으로 저장

- JSON의 활용
	1. 사람이 읽을 수 있는 설정 파일용
	2. 웹과의 연동이 필요한 데이터용
	3. 개발 중 디버깅이 중요한 데이터용

- 중요한 원칙
	- 항상 파일 존재 여부를 확인
	- 데이터 검증을 통한 안전성 확보
	- 포인터 대신 식별 정보 저장
	- 에러 처리와 방어적 프로그래밍
