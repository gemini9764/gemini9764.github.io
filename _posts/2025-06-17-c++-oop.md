---
title: STL
description: C++ STL에 대한 내용 정리
author: gemini
date: 2025-06-16 19:00:00 +09:00
categories: [C++]
tags: [stl]
math: true
mermaid: true
---

#### 응집도
 
- 클래스 내 모듈들이 얼마나 관련되어 있는지를 나타낸다
- 응집도가 높을 수록 좋음
- 클래스 내 관련없는 모듈들이 존재하게 되면, 클래스 내부가 변경되는 경우가 많고, 확장하기도 쉽지 않음

>**응집도가 낮은 경우**<br>
>응집도가 낮은 경우는 서로 관련 없는 무듈이 `class`에 있는 경우<br>
>예를 들어, 목적이 피자 배달이다. 아래의 경우, 각 기능들이 하나의 목적이 아닌 따로 노는 느낌을 주기 때문에 서로 관련없는 모듈들이 모여있다고 할 수 있다. 즉, ***응집도가 낮다***<br>
>1. 피자배달<br>
>2. 웹사이트 디자인<br>
>3. 회사 마케팅<br>
>4. 창고관리
{: .prompt-info}

>**응집도가 높은 경우**<br>
>아래의 경우, 각 기능들은 피자 배달과 관련이 있는 내용들만 있다. 이처럼 응집도가 높은 경우는 서 관련 있는 모듈들만 하나의 `class`에 있는 경우이다<br>
>이 때, ***응집도가 높다***라고 할 수 있다. 즉, 좋은 설계<br>
>1. 피자 배달 경로 확인<br>
>2. 주문한 고객 대응<br>
>3. 배달 예상 시간 측정
{: .prompt-info}

- 응집도 예시 코드

    - 응집도가 낮은 코드

    ```
    #include <iostream>
    #include <string>
    #include <algorithm> // for transform
    using namespace std;
    
    class Utility {
    public:
        void printMessage(const string& message) {
            string upperMessage = message;
            transform(upperMessage.begin(), upperMessage.end(), upperMessage.begin(), ::toupper);
            cout << "Message: " << upperMessage << endl;
        }
    
        void calculateSum(int a, int b) {
            cout << "Sum: " << (a + b) << endl;
        }
    
        void calculateProduct(int a, int b) {
            cout << "Product: " << (a * b) << endl;
        }
    
        void reverseString(const string& str) {
            string reversed = string(str.rbegin(), str.rend());
            cout << "Reversed: " << reversed << endl;
        }
    };
    
    int main() {
        Utility util;
        util.printMessage("Hello");
        util.calculateSum(5, 10);
        util.calculateProduct(5, 10);
        util.reverseString("world");
        return 0;
    }
    ```

    - 응집도가 높은 코드

    ```
    #include <iostream>
    #include <string>
    #include <algorithm> // for transform
    using namespace std;
    
    class MessageHandler {
    public:
        void printMessage(const string& message) {
            string upperMessage = message;
            transform(upperMessage.begin(), upperMessage.end(), upperMessage.begin(), ::toupper);
            cout << "Message: " << upperMessage << endl;
        }
    };
    
    class Calculator {
    public:
        void calculateSum(int a, int b) {
            cout << "Sum: " << (a + b) << endl;
        }
    
        void calculateProduct(int a, int b) {
            cout << "Product: " << (a * b) << endl;
        }
    };
    
    class StringManipulator {
    public:
        void reverseString(const string& str) {
            string reversed = string(str.rbegin(), str.rend());
            cout << "Reversed: " << reversed << endl;
        }
    };
    
    int main() {
        MessageHandler messageHandler;
        messageHandler.printMessage("Hello");
    
        Calculator calculator;
        calculator.calculateSum(5, 10);
        calculator.calculateProduct(5, 10);
    
        StringManipulator stringManipulator;
        stringManipulator.reverseString("world");
    
        return 0;
    }
    ```


#### 결합도

- 각 모듈들의 서로 얼마나 의존하는지 나타냄
- 결합도가 낮은게 좋은 코드
- 결합도가 높게되면 각 모듈들은 서로 의존적이게 되므로, 하나의 모듈이 변결될 때 다른 모듈까지 영향을 미치게 된다

- 결합도 예시 코드

    - 결합도가 높은 코드
    ```
    #include <iostream>
    #include <string>

    using namespace std;

    // 기존 Engine 클래스
    class Engine {
    public:
        string state;

        Engine() : state("off") {}

        void start() {
            state = "on";
            cout << "Engine started" << endl;
        }
    };

    // 새로운 ElectricEngine 클래스 (기존 Engine과는 별도)
    class ElectricEngine {
    public:
        string state;

        ElectricEngine() : state("off") {}

        void start() {
            state = "on";
            cout << "Electric Engine running silently" << endl;
        }
    };

    // 기존 Car 클래스 수정
    class Car {
    public:
        Engine engine; // Car 클래스는 여전히 Engine 클래스에 강하게 의존

        void startCar() {
            if (engine.state == "off") {
                engine.start();
                cout << "Car started" << endl;
            }
        }
    };
    ```

    - 결합도가 낮은 코드

    ```
    #include <iostream>
    #include <memory>

    using namespace std;

    // 공통 인터페이스 정의
    class Engine {
    public:
        virtual void start() = 0;
        virtual ~Engine() = default;
    };

    // DieselEngine 구현
    class DieselEngine : public Engine {
    public:
        void start() {
            cout << "Diesel Engine started" << endl;
        }
    };

    // 새로운 ElectricEngine 구현
    class ElectricEngine : public Engine {
    public:
        void start() {
            cout << "Electric Engine started silently" << endl;
        }
    };

    // Car 클래스는 Engine 인터페이스에만 의존
    class Car {
    private:
        unique_ptr<Engine> engine;

    public:
        Car(unique_ptr<Engine> eng) : engine(move(eng)) {}
        void startCar() {
            engine->start();
            cout << "Car started" << endl;
        }
    };

    int main() {
        // DieselEngine을 사용하는 경우
        auto dieselEngine = make_unique<DieselEngine>();
        Car dieselCar(move(dieselEngine));
        dieselCar.startCar();

        // ElectricEngine을 사용하는 경우
        auto electricEngine = make_unique<ElectricEngine>();
        Car electricCar(move(electricEngine));
        electricCar.startCar();
        return 0;
    }
    ```


#### SOLID 원칙

- 객체지향을 설계할 때 주요한 5가지 원칙
    - 유지보수성 및 확장성 향상