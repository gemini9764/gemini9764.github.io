---
title: 언리얼 메모리 관리
description: 메모리 관리
author: gemini
date: YYYY-MM-DD HH:MM:SS +09:00
categories: [Unreal, part1]
tags: [memory]
math: true
mermaid: true
---

**C++ 언어 메모리 관리의 문제점**
- C++은 저수준으로 메모리 주소에 직접 점근하는 포인터를 사용해 오브젝트를 관리한다
- 그러다보니 프로그래머가 직접 할당(new)과 해지(delete) 짝 맞추기를 해야 한다
- 이를 잘 지키지 못하는 경우 다양한 문제가 발생할 수 있음

>**잘못된 포인터 사용 예시**<br>
>**메모리 누수(Leak)** : new를 했는데 delete 짝을 맞추지 못함. 힙에 메모리가 그대로 남아있음<br>
>**허상(Dangling) 포인터** : (다른 곳에서) 이미 해제해 무효화된 오브젝트의 주소를 가리키는 포인터<br>
>**와일드(Wild) 포인터** : 값이 초기화되지 않아 엉뚱한 주소를 가리키는 포인터<br>
{: .prompt-info}	

- 잘못된 포인터 값은 다양한 문제를 일으키며, 한 번의 실수는 프로그램을 종료시킴
- 게임 규모가 커지고 구조가 복잡해질수록 프로그래머가 실수할 확률은 크게 증가한다

>C++ 이후에  나온 언어 Java/C#은 이런 고질적인 문제를 해결하기 위해 포인터를 버리고 대신 가비지 컬렉션 시스템을 도입함
{: .prompt-tip}

[가비지 컬렉션 시스템 포스트](https://gemini9764.github.io/posts/unreal-garbage/)

<!--[언리얼 엔진의 가비지 컬렉션 시스템 포스트]-->

---------------------------------------------------------

**언리얼 오브젝트를 통한 포인터 문제의 해결**
- **메모리 누수 문제**
	- 언리얼 오브젝트는 가비지 컬렉터를 통해 자동으로 해결
	- C++ 오브젝트는 직접 신경써야 함(스마트 포인터 라이브러리의 활용)

- **댕글링 포인터 문제**
	- 언리얼 오브젝트는 이를 탐지하기 위한 함수를 제공함 ::IsValid()
	- C++ 오브젝트는 직접 신경써야 함(스마트 포인터 라이브러리의 활용)

- **와일드 포인터 문제**
	- 언리얼 오브젝트에 UPROPERTY 속성을 지정하면 자동으로 nullptr로 초기화 해줌
	- C++오브젝트의 포인터는 직접 nullptr 로 초기화 할 것(또는 스마트 포인터 라이브러리의 활용)

---------------------------------------------------------

**회수되지 않는 언리얼 오브젝트**
- 언리얼 엔젠 방식으로 참조를 설정한 언리얼 오브젝트
	- **UPROPERTY**로 참조된 언리얼 오브젝트(대부분의 경우 이를 사용)
	- **AddReferencedObject 함수**를 통해 참조를 설정한 언리얼 오브젝트

- 루트셋(RootSet)으로 지정된 언리얼 오브젝트

>(오브젝트 선언의 기본 원칙)<br>
>오브젝트 포인터는 가급적 UPROPERTY로 선언하고,<br>
>메모리는 가비지 컬렉터가 자동으로 관리하도록 위임한다
{: .prompt-tip}

---------------------------------------------------------

**일반 클래스에서 언리얼 오브젝트를 관리하는 경우**
- UPROPERTY를 사용하지 못하는 일반 C++ 클래스가 언리얼 오브젝트를 관리해야 하는 경우
- FGCObject 클래스를 상속받은 후 AddReferencedObjects 함수를 구현한다
- 함수 구현부에서 관리할 언리얼 오브젝트를 추가해 줌
- ![일반 클래스에서 언리얼 오브젝트를 관리하는 경우.png](/assets/img/posts/file_photos/일반%20클래스에서%20언리얼%20오브젝트를%20관리하는%20경우.png)

***시스템을 구축하면서 필요한 상황이 발생할 수 있음***

---------------------------------------------------------

**언리얼 오브젝트의 관리 원칙**
- 생성된 언리얼 오브젝트를 유지하기 위해 레퍼런스 참조 방법을 설계할 것
	- 언리얼 오브젝트 내의 언리얼 오브젝트 : **UPROPERTY** 사용 
	- 일반 C++ 오브젝트 내의 언리얼 오브젝트 : **FGCObject**의 상속 후 구현

- 생성된 언리얼 오브젝트는 강제로 지우려 하지 말 것
	- 참조를 끊는다는 생각으로 설계할 것
	- 가비지 컬렉터에게 회수를 재촉할 수는 있음(ForceGarbageCollection 함수)
	- 콘텐츠 제작에서 Destroy 함수를 사용할 수 있으나, 결국 내부 동작은 동일함 (가비지 컬렉터에 위임)

---------------------------------------------------------

**가비지 컬렉션 테스트 환경 제작**
- 프로젝트 설정에서 가비지 컬렉션 GCCycle 시간을 3초로 단축 설정
- 새로운 GameInstance의 두 함수를 오버라이드
	- Init : 어플리케이션이 초기화될 때 호출
	- Shutdown : 어플리케이션이 종료될 때 호출

- 테스트 시나리오
	- 플레이 버튼을 누를 때 Init 함수에서 오브젝트를 생성하고
	- 3초 이상 대기해 가비지 컬렉션을 발동
	- 플레이 중지를 눌러 Shutdown  함수에서 생성한 오브젝트의 유효성을 확인
	- ![가비지 컬렉션 테스트 환경 시나리오.png](/assets/img/posts/file_photos/가비지%20컬렉션%20테스트%20환경%20시나리오.png)