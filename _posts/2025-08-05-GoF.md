---
title: GoF 디자인 패턴1
description: 생성 패턴과 구조 패턴
author: gemini
date: 2025-08-05 19:00:00 +09:00
categories: [Unreal]
tags: [GoF]
math: true
mermaid: true
---

#### GoF (Gang of Four)
- Erich Gamma
- Richard Helm
- Ralph Johnson
- John Vlissides


#### 생성패턴 (5개)
- 객체 생성 메커니즘 (HOW to create)
- Singleton, Factory Method, Abstract Factory, Builder, Prototype


#### 구조 패턴 (7개)
- 클래스나 객체를 조합하는 패턴 (HOW to compose)
- Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy


#### 행동 패턴 (11개)
- 객체 간 상호작용과 책임 분배 패턴 (HOW to compose)
- Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy


#### 실무 핵심 10개 패턴

- **사용 빈도 분석***
	- 매우 자주 사용 : Singleton, Factory, Observer
	- 자주 사용 : Builder, Decorator, Command, State
	- 가끔 사용 : Adapter, Facade, Strategy
	- 거의 안씀 : 나머지 13개


#### 생성 패턴 (Creational Patterns)

##### 싱글톤 패턴 (Singleton Pattern) - 게임 매니저의 필수품

- 개념
	- 클래스의 인스턴스가 단 하나만 존재하도록 보장, 어디서든 접근할 수 있게 하는 패턴

- 언제 필요?
	- GameManager처럼 게임 전체를 관리하는 객체
	- 여러 개 있으면 혼란을 일으키는 시스템
	- 모든 곳에서 접근해야 하는 중앙 관리자

- 언리얼 엔진 스타일

```
UCLASS()
class MYGAME_API UMyGameInstance : public UGameInstance {
    GENERATED_BODY()
    
private:
    UPROPERTY()
    int32 TotalScore;
    
public:
    // 편의 메서드
    static UMyGameInstance* Get() {
        return Cast<UMyGameInstance>(
            UGameplayStatics::GetGameInstance(GetWorld())
        );
    }
    
    void AddScore(int32 Points) { TotalScore += Points; }
};

// 사용
UMyGameInstance::Get()->AddScore(100);
```

- 사용 가이드라인
	- 적합한 경우
		- GameManager (게임 상태 관리)
		- AudioManager (사운드 시스템)
		- SaveManager (저장 시스템)
		- NetworkManager (네트워크 연결)
		- ResourcePool (리소스 캐시)
	- 피해야 할 경우
		- Player, Enemy (게임 오브젝트)
		- Weapon, Item (여러 개 존재)
		- UI 요소들
		- 임시 오브젝트


##### 팩토리 패턴 (Factory Method Pattern) - 몬스터 생성의 정석

- 개념
	- 객체 생성을 별도의 메서드로 캡슐화하여, 생성 로직을 한 곳에서 관리하는 패턴

- 언제 필요?
	- 다양한 종류의 몬스터/아이템을 생성
	- 조건에 따라 다른 객체를 생성
	- 생성 로직이 복잡하고 자주 변경

- 실제 사용

```
class GameMode {
    std::unique_ptr<EnemySpawner> currentSpawner;
    
    // 스테이지에 따라 다른 스포너 사용
    void SetupStage(int stageNumber) {
        switch (stageNumber) {
            case 1:
                // 1스테이지는 좀비만!
                currentSpawner = std::make_unique<ZombieSpawner>();
                UE_LOG(LogTemp, Warning, TEXT("1스테이지: 좀비 공장 가동!"));
                break;
                
            case 2:
                // 2스테이지는 스켈레톤!
                currentSpawner = std::make_unique<SkeletonSpawner>();
                UE_LOG(LogTemp, Warning, TEXT("2스테이지: 스켈레톤 공장 가동!"));
                break;
        }
    }
    
    // 적 스폰하기
    void SpawnEnemyWave() {
        if (currentSpawner) {
            // 현재 공장에서 적 생산!
            currentSpawner->SpawnEnemy(GetRandomLocation());
            // 어떤 적이 나올지는 currentSpawner가 결정!
        }
    }
};
```

- 사용 가이드라인
	- 적합한 경우
		- 몬스터/아이템/무기 생성 시스템
		- 난이도별 오브젝트 생성
		- UI 요소 동적 생성
		- 파티클 이펙트 생성
	- 피해야 할 경우
		- 단순한 객체 (한 종류만)
		- 생성 로직이 없는 경우
		- 성능이 극도로 중요한 경우


##### 빌더 패턴 (Builder Pattern) - 캐릭터를 조립하듯이 만들기

- 개념
	- 복잡한 객체를 단계별로 생성할 수 있게 하는 패턴. 생성 과정과 표현을 분리하여 동일한 생성 절차에서 다른 표현을 만들 수 있음

- 언제 필요?
	- 캐릭터 커스터마이징처럼 옵션이 많을 때
	- 생성자 매개변수가 너무 많을 때
	- 선택적 매개변수가 많을 때
	- 객체 생성 과정이 여러 단계일 때

- Builder 패턴 구조
1. 생성될 복잡한 객체

```
class Character {
private:  // private으로 숨겨둬요!
    // 기본 정보
    FString Name;
    FString Class;
    int Level;
    
    // 외형
    FLinearColor SkinColor;
    FLinearColor HairColor;
    int HairStyle;
    float Height;
    
    // 능력치
    float Health;
    float Mana;
    float Strength;
    float Intelligence;
    float Agility;
    
    // 장비
    FString Weapon;
    FString Armor;
    
    // 스킬
    TArray<FString> Skills;
    
public:
    // Builder를 friend로 선언 - Builder만 접근 가능!
    friend class CharacterBuilder;
    
    void PrintInfo() {
        UE_LOG(LogTemp, Warning, TEXT("=== 캐릭터 정보 ==="));
        UE_LOG(LogTemp, Warning, TEXT("이름: %s"), *Name);
        UE_LOG(LogTemp, Warning, TEXT("직업: %s"), *Class);
        UE_LOG(LogTemp, Warning, TEXT("레벨: %d"), Level);
        UE_LOG(LogTemp, Warning, TEXT("체력: %.1f"), Health);
    }
};
```

2. Builder 클래스

```
class CharacterBuilder {
private:
    Character* character;  // 조립 중인 캐릭터
    
public:
    CharacterBuilder() {
        character = new Character();
        
        // 기본값 세팅 - 이러면 일부만 설정해도 OK!
        character->Level = 1;
        character->Height = 1.8f;
        character->Health = 100.0f;
        character->Mana = 100.0f;
        character->Strength = 10.0f;
        character->Intelligence = 10.0f;
        character->Agility = 10.0f;
    }
    
    // 이름 설정하고 자기 자신을 반환!
    CharacterBuilder& WithName(const FString& name) {
        character->Name = name;
        return *this;  // 이게 핵심! 체이닝을 위해!
    }
    
    // 직업 설정
    CharacterBuilder& WithClass(const FString& className) {
        character->Class = className;
        return *this;
    }
    
    // 레벨 설정
    CharacterBuilder& WithLevel(int level) {
        character->Level = level;
        return *this;
    }
    
    // 외형을 한 번에 설정
    CharacterBuilder& WithAppearance(
        FLinearColor skin, 
        FLinearColor hair, 
        int hairStyle
    ) {
        character->SkinColor = skin;
        character->HairColor = hair;
        character->HairStyle = hairStyle;
        return *this;
    }
    
    // 능력치를 한 번에 설정
    CharacterBuilder& WithStats(
        float health, 
        float mana, 
        float strength, 
        float intelligence
    ) {
        character->Health = health;
        character->Mana = mana;
        character->Strength = strength;
        character->Intelligence = intelligence;
        return *this;
    }
    
    // 무기 장착
    CharacterBuilder& WithWeapon(const FString& weapon) {
        character->Weapon = weapon;
        return *this;
    }
    
    // 스킬 추가 (여러 번 호출 가능!)
    CharacterBuilder& AddSkill(const FString& skill) {
        character->Skills.Add(skill);
        return *this;
    }
    
    // 최종 빌드! 완성된 캐릭터를 반환
    Character* Build() {
        // 마지막 검증
        if (character->Name.IsEmpty()) {
            character->Name = "Unknown Hero";  // 이름 없으면 기본값
        }
        
        // 직업별 보너스 적용
        ApplyClassDefaults();
        
        return character;  // 완성!
    }
    
private:
    void ApplyClassDefaults() {
        if (character->Class == "Warrior") {
            // 전사는 체력과 힘 보너스!
            character->Health *= 1.5f;
            character->Strength *= 1.3f;
            
            if (character->Weapon.IsEmpty()) {
                character->Weapon = "Iron Sword";  // 기본 무기
            }
        }
        else if (character->Class == "Mage") {
            // 마법사는 마나와 지능 보너스!
            character->Mana *= 2.0f;
            character->Intelligence *= 1.5f;
            
            if (character->Weapon.IsEmpty()) {
                character->Weapon = "Wooden Staff";  // 기본 무기
            }
        }
    }
};
```


- 사용 방법

```
// 방법 1: 풀 커스터마이징
Character* myHero = CharacterBuilder()
    .WithName("Arthas")
    .WithClass("Warrior")
    .WithLevel(50)
    .WithAppearance(
        FLinearColor(1, 0.8f, 0.6f),    // 피부색
        FLinearColor(0.2f, 0.2f, 0.2f), // 검은 머리
        3                                // 헤어스타일 3번
    )
    .WithStats(500, 100, 50, 20)        // 체력, 마나, 힘, 지능
    .WithWeapon("Frostmourne")
    .AddSkill("Death Coil")
    .AddSkill("Army of the Dead")
    .Build();

// 방법 2: 간단하게 필요한 것만!
Character* simpleHero = CharacterBuilder()
    .WithName("John")
    .WithClass("Archer")
    .Build();  // 나머지는 다 기본값!

// 방법 3: 순서 상관없이!
Character* wizard = CharacterBuilder()
    .AddSkill("Fireball")        // 스킬부터 추가해도 OK
    .WithClass("Mage")           // 순서 바꿔도 OK
    .WithName("Gandalf")         // 편한 대로!
    .AddSkill("Teleport")
    .WithLevel(99)
    .Build();
```

- 사용 가이드라인
	- 적합한 경우
		- 캐릭터 커스터마이징 시스템
		- 복잡한 아이템 제작
		- UI 레이아웃 구성
		- 게임 설정 구성
		- 던전/맵 생성 시스템
	- 피해야 할 경우
		- 매개변수가 적고 단순한 객체
		- 모든 값이 필수인 경우
		- 객체 구조가 자주 변경되는 경우


#### 구조 패턴 (Sturctural Patterns)

##### 어댑터 패턴 (Adapter Pattern) - 서로 안 맞는 것들을 연결

- 개념
	- 호환되지 않은 인터페이스를 가진 클래스를 함께 작동할 수 있도록 변환해주는 패턴

- 언제 필요?
	- 외부 라이브러리를 우리 코드와 통합할 때
	- 플랫폼별로 다른 API를 통일된 방식으로 사용
	- 레거시 코드를 새로운 시스템과 연동
	- 서로 다른 엔진/SDK를 함께 사용

- Adapter 패턴 구조
1. 통합 인터페이스 정의

```
// 우리가 원하는 공통 인터페이스
class IVector3D {
public:
    virtual float GetX() const = 0;
    virtual float GetY() const = 0;
    virtual float GetZ() const = 0;
    virtual float GetMagnitude() const = 0;
    virtual ~IVector3D() = default;
};
```

2. Adapter 만들기 - 변환기

```
// 언리얼 벡터를 위한 어댑터
class FVectorAdapter : public IVector3D {
private:
    FVector* vector;  // 언리얼 벡터를 가리킴
    
public:
    FVectorAdapter(FVector* vec) : vector(vec) {}
    
    // IVector3D 인터페이스 구현
    float GetX() const override { 
        return vector->X;  // 언리얼은 X로 바로 접근
    }
    
    float GetY() const override { 
        return vector->Y; 
    }
    
    float GetZ() const override { 
        return vector->Z; 
    }
    
    float GetMagnitude() const override { 
        return vector->Size();  // Size()를 GetMagnitude()로 변환!
    }
};

// 물리 엔진 벡터를 위한 어댑터
class PhysicsVectorAdapter : public IVector3D {
private:
    PhysicsVec3* physicsVector;  // 물리 엔진 벡터를 가리킴
    
public:
    PhysicsVectorAdapter(PhysicsVec3* vec) : physicsVector(vec) {}
    
    float GetX() const override { 
        return physicsVector->getX();  // getX()를 GetX()로 변환!
    }
    
    float GetY() const override { 
        return physicsVector->getY(); 
    }
    
    float GetZ() const override { 
        return physicsVector->getZ(); 
    }
    
    float GetMagnitude() const override { 
        return physicsVector->magnitude();  // magnitude()를 GetMagnitude()로!
    }
};
```

3. 하나의 함수로 모두 처리

```
// 이제 하나의 함수로 모든 벡터 처리 가능!
void MoveCharacter(IVector3D* direction) {
    float x = direction->GetX();
    float y = direction->GetY();
    float z = direction->GetZ();
    float speed = direction->GetMagnitude();
    
    UE_LOG(LogTemp, Warning, TEXT("이동: (%.2f, %.2f, %.2f), 속도: %.2f"), 
           x, y, z, speed);
    
    // 캐릭터 이동 로직... (한 번만 구현!)
}

// 사용 예시
void GamePlay() {
    // 언리얼 벡터 사용
    FVector unrealVec(10, 20, 30);
    FVectorAdapter unrealAdapter(&unrealVec);
    MoveCharacter(&unrealAdapter);  // 잘 동작!
    
    // 물리 엔진 벡터 사용
    PhysicsVec3 physicsVec;  // (10, 20, 30)으로 초기화
    PhysicsVectorAdapter physicsAdapter(&physicsVec);
    MoveCharacter(&physicsAdapter);  // 이것도 잘 동작!
}
```

- 사용 가이드라인
	- 적합한 경우
		- 외부 SDK/라이브러리 통합
		- 크로스 플랫폼 개발
		- 레거시 시스템 연동
		- 다양한 API  통합 (렌더링, 오디오, 네트워크)
	- 피해야 할 경우
		- 인터페이스가 이미 호환되는 경우
		- 단순한 데이터 변환만 필요한 경우
		- 성능이 극도로 중요한 경우


##### 데코레이터 패턴 (Decorator Pattern) - 무기에 인챈트 걸기

- 개념
	- 객체에 동적으로 새로운 책임 (기능)을 추가할 수 있게 하는 패턴. 기능 확장이 필요할 때 서브클래싱 대신 사용

- 언제 필요?
	- 무기에 여러 인챈드를 조합하고 싶을 때
	- 버프/디버프를 중첩해서 적용할 때
	- 기본 기능에 옵션을 동적으로 추가/제거할 때
	- 상속으로는 조합이 폭발적으로 증가하는 경우

- 데코레이터 패턴 구조
1. 무기 인터페이스 - 모든 무기의 기본

```
// 모든 무기가 가져야 할 기본 기능
class IWeapon {
public:
    virtual float GetDamage() const = 0;        // 데미지
    virtual float GetAttackSpeed() const = 0;   // 공격 속도
    virtual FString GetDescription() const = 0;  // 설명
    virtual float GetPrice() const = 0;         // 가격
    virtual ~IWeapon() = default;
};
```

2. 기본 무기들 - 인챈트 없는 순수한 무기

```
// 기본 검
class BasicSword : public IWeapon {
public:
    float GetDamage() const override { 
        return 50.0f;  // 기본 데미지 50
    }
    
    float GetAttackSpeed() const override { 
        return 1.0f;   // 기본 공속 1.0
    }
    
    FString GetDescription() const override { 
        return "Basic Sword";  // 그냥 기본 검
    }
    
    float GetPrice() const override { 
        return 100.0f;  // 100골드
    }
};

// 기본 활
class BasicBow : public IWeapon {
public:
    float GetDamage() const override { return 40.0f; }
    float GetAttackSpeed() const override { return 1.5f; }  // 활은 빨라!
    FString GetDescription() const override { return "Basic Bow"; }
    float GetPrice() const override { return 150.0f; }
};
```

3. Decorator 베이스 - 인챈트의 부모

```
// 모든 인챈트의 부모 클래스
class WeaponDecorator : public IWeapon {
protected:
    IWeapon* baseWeapon;  // 감쌀 무기를 저장
    
public:
    WeaponDecorator(IWeapon* weapon) : baseWeapon(weapon) {}
    
    virtual ~WeaponDecorator() {
        delete baseWeapon;  // 메모리 정리
    }
    
    // 기본 동작은 그냥 전달 (위임)
    float GetDamage() const override { 
        return baseWeapon->GetDamage();  // 안쪽 무기의 데미지 그대로
    }
    
    float GetAttackSpeed() const override { 
        return baseWeapon->GetAttackSpeed(); 
    }
    
    FString GetDescription() const override { 
        return baseWeapon->GetDescription(); 
    }
    
    float GetPrice() const override { 
        return baseWeapon->GetPrice(); 
    }
};
```

4. 구체적인 인챈트들

```
// 화염 인챈트
class FireEnchantment : public WeaponDecorator {
private:
    float fireDamage = 20.0f;  // 화염 추가 데미지
    
public:
    FireEnchantment(IWeapon* weapon) : WeaponDecorator(weapon) {}
    
    float GetDamage() const override {
        // 기존 데미지 + 화염 데미지!
        return baseWeapon->GetDamage() + fireDamage;
    }
    
    FString GetDescription() const override {
        // 기존 설명 + 화염 설명!
        return baseWeapon->GetDescription() + " [Fire +20]";
    }
    
    float GetPrice() const override {
        // 인챈트 비용 추가!
        return baseWeapon->GetPrice() + 500.0f;
    }
};

// 얼음 인챈트
class IceEnchantment : public WeaponDecorator {
private:
    float iceDamage = 15.0f;
    float slowEffect = 0.2f;  // 20% 둔화 효과
    
public:
    IceEnchantment(IWeapon* weapon) : WeaponDecorator(weapon) {}
    
    float GetDamage() const override {
        return baseWeapon->GetDamage() + iceDamage;
    }
    
    FString GetDescription() const override {
        return baseWeapon->GetDescription() + " [Ice +15, Slow 20%]";
    }
    
    float GetPrice() const override {
        return baseWeapon->GetPrice() + 400.0f;
    }
};

// 번개 인챈트
class LightningEnchantment : public WeaponDecorator {
private:
    float lightningDamage = 25.0f;
    
public:
    LightningEnchantment(IWeapon* weapon) : WeaponDecorator(weapon) {}
    
    float GetDamage() const override {
        return baseWeapon->GetDamage() + lightningDamage;
    }
    
    float GetAttackSpeed() const override {
        // 번개는 공속도 올려줘요!
        return baseWeapon->GetAttackSpeed() * 1.2f;  // 20% 증가
    }
    
    FString GetDescription() const override {
        return baseWeapon->GetDescription() + " [Lightning +25, Speed +20%]";
    }
    
    float GetPrice() const override {
        return baseWeapon->GetPrice() + 800.0f;
    }
};

// 예리함 인챈트 (곱셈 효과!)
class SharpnessEnchantment : public WeaponDecorator {
private:
    float damageMultiplier = 1.5f;  // 1.5배!
    
public:
    SharpnessEnchantment(IWeapon* weapon) : WeaponDecorator(weapon) {}
    
    float GetDamage() const override {
        // 곱셈이라 순서가 중요해요!
        return baseWeapon->GetDamage() * damageMultiplier;
    }
    
    FString GetDescription() const override {
        return baseWeapon->GetDescription() + " [Sharpness x1.5]";
    }
    
    float GetPrice() const override {
        return baseWeapon->GetPrice() + 1000.0f;
    }
};
```

5. 사용 방법

```
void CreateMyUltimateWeapon() {
    // 1단계: 기본 검 생성
    IWeapon* mySword = new BasicSword();
    UE_LOG(LogTemp, Warning, TEXT("%s - 데미지: %.1f, 가격: %.1f"), 
           *mySword->GetDescription(), 
           mySword->GetDamage(), 
           mySword->GetPrice());
    // 출력: "Basic Sword - 데미지: 50.0, 가격: 100.0"
    
    // 2단계: 화염 인챈트 추가!
    mySword = new FireEnchantment(mySword);
    UE_LOG(LogTemp, Warning, TEXT("%s - 데미지: %.1f, 가격: %.1f"), 
           *mySword->GetDescription(), 
           mySword->GetDamage(), 
           mySword->GetPrice());
    // 출력: "Basic Sword [Fire +20] - 데미지: 70.0, 가격: 600.0"
    
    // 3단계: 번개 인챈트 추가!
    mySword = new LightningEnchantment(mySword);
    UE_LOG(LogTemp, Warning, TEXT("%s - 데미지: %.1f, 공속: %.1f"), 
           *mySword->GetDescription(), 
           mySword->GetDamage(), 
           mySword->GetAttackSpeed());
    // 출력: "Basic Sword [Fire +20] [Lightning +25, Speed +20%] - 데미지: 95.0, 공속: 1.2"
    
    // 4단계: 예리함 추가! (순서 중요!)
    mySword = new SharpnessEnchantment(mySword);
    // 최종: 데미지 = 95.0 * 1.5 = 142.5!
}
```

- 사용 가이드라인
	- 적합한 경우
		- 무기/방어구 인챈트 시스템
		- 버프/디버프 시스템
		- UI 스타일 중첩
		- 스킬 강화 시스템
		- 런타임에 기능 추가/제거
	- 피해야 할 경우
		- 기능이 고정적인 경우
		- 조합이 많지 않은 경우
		- 성능이 극도로 중요한 경우 (많은 래핑)


##### 퍼사드 패턴 (Facade Pattern) - 복잡한 것을 간단하게

- 개념
	- 복잡한 서브시스템들을 하나의 간단한 인터페이스로 통합하여 제공하는 패턴. 복잡함을 숨기고 사용하기 쉽게 만듦

- 언제 필요?
	- 게임 시작 시 수많은 시스템을 초기화할 때
	- 복잡한 라이브러리를 간단한게 사용하고 싶을때
	- 여러 서브시스템을 조합해서 사용해야 할 때
	- 클라이언트가 내부 구조를 몰라도 되게 하고 싶을 때

- 퍼사드 패턴 구조
1. 복잡한 서브시스템들

```
// 렌더링 시스템 - 그래픽 담당
class RenderingSystem {
public:
    void Initialize() {
        UE_LOG(LogTemp, Warning, TEXT("렌더링 시스템 초기화 중..."));
        LoadShaders();
        SetupRenderTargets();
        InitializePostProcessing();
    }
    
    void LoadShaders() { 
        UE_LOG(LogTemp, Warning, TEXT("셰이더 로딩..."));
    }
    
    void SetupRenderTargets() { 
        UE_LOG(LogTemp, Warning, TEXT("렌더 타겟 설정..."));
    }
    
    void InitializePostProcessing() { 
        UE_LOG(LogTemp, Warning, TEXT("포스트 프로세싱 초기화..."));
    }
    
    void SetResolution(int width, int height) { 
        UE_LOG(LogTemp, Warning, TEXT("해상도 설정: %dx%d"), width, height);
    }
    
    void EnableVSync(bool enable) { 
        UE_LOG(LogTemp, Warning, TEXT("수직동기화: %s"), enable ? TEXT("ON") : TEXT("OFF"));
    }
};

// 오디오 시스템 - 소리 담당
class AudioSystem {
public:
    void Initialize() {
        UE_LOG(LogTemp, Warning, TEXT("오디오 시스템 초기화 중..."));
        InitializeAudioDevice();
        LoadAudioBanks();
        SetupAudioChannels();
    }
    
    void InitializeAudioDevice() { /* 오디오 장치 설정 */ }
    void LoadAudioBanks() { /* 사운드 파일 로딩 */ }
    void SetupAudioChannels() { /* 5.1채널, 스테레오 등 */ }
    void SetMasterVolume(float volume) { /* 마스터 볼륨 */ }
    
    void PlayBGM(const FString& musicName) { 
        UE_LOG(LogTemp, Warning, TEXT("BGM 재생: %s"), *musicName);
    }
};

// 그 외 시스템들도 마찬가지...
```

2. Facade 클래스 - 간단한 인터페이스

```
class GameSystemFacade {
private:
    // 모든 복잡한 시스템들을 내부에 숨겨요
    RenderingSystem* renderer;
    AudioSystem* audio;
    InputSystem* input;
    NetworkSystem* network;
    ResourceSystem* resources;
    
public:
    GameSystemFacade() {
        // Facade가 모든 시스템을 관리
        renderer = new RenderingSystem();
        audio = new AudioSystem();
        input = new InputSystem();
        network = new NetworkSystem();
        resources = new ResourceSystem();
    }
    
    ~GameSystemFacade() {
        // 메모리 정리도 Facade가 알아서
        delete renderer;
        delete audio;
        delete input;
        delete network;
        delete resources;
    }
    
    // 싱글플레이어 게임 시작 - 한 줄로 끝!
    void StartSinglePlayerGame() {
        UE_LOG(LogTemp, Warning, TEXT("=== 싱글플레이어 게임 시작 ==="));
        
        // 1. 필수 시스템만 초기화
        renderer->Initialize();
        audio->Initialize();
        input->Initialize();
        // 네트워크는 싱글플레이어니까 스킵!
        
        // 2. 싱글플레이어에 맞는 설정 자동 적용
        ApplyGraphicsSettings(EGraphicsQuality::High);  // 높은 그래픽
        ApplyAudioSettings(0.8f, 0.6f, 0.7f);          // 볼륨 설정
        
        // 3. 리소스 로딩
        resources->LoadGameResources();
        resources->PreloadLevel("Tutorial");  // 튜토리얼 레벨 준비
        
        // 4. 게임 시작!
        audio->PlayBGM("MainTheme");
        
        UE_LOG(LogTemp, Warning, TEXT("=== 게임 준비 완료! ==="));
    }
    
    // 멀티플레이어 게임 시작
    void StartMultiplayerGame(const FString& serverIP, bool isHost) {
        UE_LOG(LogTemp, Warning, TEXT("=== 멀티플레이어 게임 시작 ==="));
        
        // 1. 멀티플레이어는 네트워크도 필요!
        renderer->Initialize();
        audio->Initialize();
        input->Initialize();
        network->Initialize();  // 네트워크 추가!
        
        // 2. 호스트인지 클라이언트인지에 따라 다르게
        if (isHost) {
            network->SetConnectionType(true);
            UE_LOG(LogTemp, Warning, TEXT("호스트로 게임 생성"));
        } else {
            network->SetConnectionType(false);
            network->ConnectToServer(serverIP);
            UE_LOG(LogTemp, Warning, TEXT("서버 %s에 접속"), *serverIP);
        }
        
        // 3. 멀티플레이어는 성능이 중요! 그래픽 낮춤
        ApplyGraphicsSettings(EGraphicsQuality::Medium);
        ApplyAudioSettings(0.8f, 0.6f, 0.7f);
        
        // 4. 멀티플레이어 전용 리소스
        resources->LoadGameResources();
        resources->PreloadLevel("MultiplayerLobby");
        
        audio->PlayBGM("MultiplayerTheme");
    }
    
    // 그래픽 품질 설정도 간단하게!
    enum class EGraphicsQuality { Low, Medium, High, Ultra };
    
    void ApplyGraphicsSettings(EGraphicsQuality quality) {
        switch (quality) {
            case EGraphicsQuality::Low:
                // 저사양 PC용
                renderer->SetResolution(1280, 720);
                renderer->EnableVSync(false);
                UE_LOG(LogTemp, Warning, TEXT("그래픽: 낮음 (720p)"));
                break;
                
            case EGraphicsQuality::High:
                // 일반 게이밍 PC용
                renderer->SetResolution(1920, 1080);
                renderer->EnableVSync(true);
                UE_LOG(LogTemp, Warning, TEXT("그래픽: 높음 (1080p)"));
                break;
                
            case EGraphicsQuality::Ultra:
                // 고사양 PC용
                renderer->SetResolution(3840, 2160);
                renderer->EnableVSync(true);
                UE_LOG(LogTemp, Warning, TEXT("그래픽: 울트라 (4K)"));
                break;
        }
    }
    
    // 오디오 설정도 간단하게!
    void ApplyAudioSettings(float master, float sfx, float bgm) {
        audio->SetMasterVolume(master);
        // SFX 볼륨, BGM 볼륨 등도 설정...
        UE_LOG(LogTemp, Warning, TEXT("오디오 설정 완료"));
    }
    
    // 빠른 테스트용 메서드
    void QuickTestMode() {
        UE_LOG(LogTemp, Warning, TEXT("=== 빠른 테스트 모드 ==="));
        
        // 최소한의 초기화만!
        renderer->Initialize();
        renderer->SetResolution(1280, 720);  // 낮은 해상도로
        input->Initialize();
        
        // 테스트 레벨 바로 로드
        resources->PreloadLevel("TestArena");
        
        UE_LOG(LogTemp, Warning, TEXT("테스트 준비 완료! (3초 걸림)"));
    }
};
```

3. 사용 방법

```
// Facade 없이 - 50줄 이상의 복잡한 코드
void OldWayToStartGame() {
    RenderingSystem* renderer = new RenderingSystem();
    renderer->Initialize();
    renderer->LoadShaders();
    // ... 50줄 더
}

// Facade 사용 - 단 2줄!
void NewWayToStartGame() {
    GameSystemFacade* gameFacade = new GameSystemFacade();
    
    // 싱글플레이어? 한 줄!
    gameFacade->StartSinglePlayerGame();
    
    // 멀티플레이어 호스트? 한 줄!
    gameFacade->StartMultiplayerGame("", true);
    
    // 클라이언트로 접속? 한 줄!
    gameFacade->StartMultiplayerGame("192.168.1.100", false);
    
    // 테스트? 한 줄!
    gameFacade->QuickTestMode();
}
```

- 사용 가이드라인
	- 적합한 경우
		- 복잡한 서브시스템 통합
		- 게임 초기화/종료 시스템
		- 세이브/로드 시스템
		- 설정 관리 시스템
		- 외부 SDK 통합
	- 피해야 할 경우
		- 단순한 기능
		- 세밀한 제어가 필요한 경우
		- 서브시스템이 자주 변경되는 경우