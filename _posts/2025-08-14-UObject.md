---
title: UObject 생명주기
description: GC와 메모리 관리
author: gemini
date: 2025-08-14 19:00:00 +09:00
categories: [Unreal]
tags: [UObject]
math: true
mermaid: true
---

#### GC와 메모리 관리

##### C++ vs Unreal GC

- 일반 C++의 문제점

```
MyClass* ptr = new MyClass();  // 생성
// ... 사용 ...
delete ptr;                    // 삭제 (필수!)
```

```
void ProblematicFunction()
{
    MyClass* obj = new MyClass();

    if (SomeCondition())
    {
        return;  // 앗! obj를 delete하지 못했다!
    }

    delete obj;  // 이 줄에 영원히 도달하지 못함
}
```

```
MyClass* obj = new MyClass();
delete obj;
delete obj;  // 같은 메모리를 두 번 지움 = 크래시!

// 또는
obj->DoSomething();  // 이미 지워진 메모리에 접근 = 크래시!
```

- 언리얼 GC의 해결책

```
UObject* obj = NewObject<UObject>();  // 생성
// ... 사용 ...
// delete 안 씀! 언리얼이 알아서 처리
```

```
UObject* player = NewObject<UObject>();    // 플레이어 생성
UObject* weapon = NewObject<UObject>();    // 무기 생성

player = nullptr;  // 플레이어를 더 이상 참조하지 않음

// 잠시 후 GC가 동작하면:
// - weapon: 여전히 weapon 변수가 참조하고 있음 → 살아남음
// - player가 가리키던 객체: 아무도 참조 안 함 → 자동 삭제
```

- GC 규칙
1. UObject 상속 클래스만 관리
2. UPROPERTY로 참조 표시 필수

```
class UMyClass : public UObject
{
    UPROPERTY()  // "이 참조는 중요해요!" 라고 GC에게 알림
    UObject* SafeRef;

    UObject* UnsafeRef;  // GC가 이 참조를 모름!
};
```

3. 절대 delete 하면 안 됨

```
UObject* obj = NewObject<UObject>();
delete obj;  // 절대 금지! 언리얼 내부가 망가짐

// 올바른 방법:
obj = nullptr;  // 참조만 끊으면 GC가 알아서 처리
```


##### UObject란? 언리얼 엔진의 핵심 상자

- 일반 C++ 클래스의 한계

```
class MyCppCharacter
{
private:
    int Health = 100;
    std::string Name = "Hero";

public:
    void TakeDamage(int Damage) { Health -= Damage; }
    int GetHealth() const { return Health; }
};
```

*블루프린트 지원 안됨, 에디터 통합 안됨, 자동 저장 안됨*

- UObject의 마법

```
UCLASS(BlueprintType)  // 블루프린트에서 사용 가능하게!
class MYGAME_API UMyCharacter : public UObject
{
    GENERATED_BODY()

private:
    UPROPERTY(EditAnywhere, BlueprintReadWrite, SaveGame, meta = (AllowPrivateAccess = "true"))
    int32 Health = 100;  // 에디터 수정 + 블루프린트 접근 + 자동 저장!

public:
    UFUNCTION(BlueprintCallable)  // 블루프린트에서 호출 가능!
    void TakeDamage(int32 Damage);
};
```

*블루프린트 지원, 에디터 통합, 자동 저장, 메모리 자동 관리*

- Object가 제공하는 핵심 기능들
1. 블루프린트 통합
2. 에디터 통합
3. 자동 저장/불러오기

```
UPROPERTY(SaveGame)
int32 PlayerLevel;  // 자동으로 세이브 파일에 포함!

UPROPERTY(SaveGame)
TArray<FString> CompletedQuests;  // 퀘스트 목록도 자동 저장!
```

4. 리플렉션
5. 메모리 자동 관리

```
// 전통적인 C++
Character* player = new Character();
Weapon* sword = new Weapon();
// ... 나중에 반드시 delete player; delete sword;

// UObject 방식
UCharacter* player = NewObject<UCharacter>();
UWeapon* sword = NewObject<UWeapon>();
// delete 없어도 GC가 알아서 정리!
```

- 언리얼 클래스 계층

```
UObject (모든 것의 시작)
├── AActor (3D 월드에 존재하는 것들)
│   ├── APawn (조종 가능한 객체)
│   │   └── ACharacter (걸어다니는 캐릭터)
│   ├── AController (두뇌 역할)
│   └── AGameMode (게임 규칙 관리)
├── UActorComponent (액터에 붙이는 부품들)
│   ├── UMeshComponent (모델 표시)
│   └── UMovementComponent (이동 처리)
└── UObject (순수 데이터/로직)
    ├── UGameInstance (게임 전체 관리)
    └── UUserWidget (UI 요소)
```

1. **통일성** - 모든 객체가 같은 방식으로 동작
2. **확장성** - 새 기능 추가 시 모든 객체가 자동으로 혜택
3. **상호 운용성** - 서로 다른 시스템끼리 쉽게 연동


##### Outer 체인 : 누가 누구의 주인인가?

- Outer = 소유 관계

```
아파트 건물 (World - 게임 세계)
  └── 101호 (Level - 현재 맵)
       └── 홍길동 (Actor - 플레이어 캐릭터)
            ├── 스마트폰 (Component - 인벤토리)
            │    └── 카카오톡 (SubObject - 아이템)
            └── 지갑 (Component - 장비)
                 ├── 신용카드 (SubObject)
                 └── 현금 (SubObject)
```

***핵심** : 주인이 사라지면 소유물도 자동 삭제*

- 전통적인 방식 vs Outer 방식
1. 자동 메모리 정리의 핵심

```
// 전통적인 방식 (복잡함)
void PlayerDied()
{
    delete player->inventory;
    delete player->weapon;
    delete player->armor;
    delete player->skills[0];
    delete player->skills[1];
    // ... 수십 개의 객체를 일일이 정리
    delete player;

    // 하나라도 빼먹으면 메모리 누수!
}
```

```
// Outer 방식 (간단함)
void PlayerDied()
{
    player->Destroy();  // 이 한 줄로 끝!
    // 플레이어가 소유한 모든 것들이 자동으로 연쇄 정리됨
}
```

2. GC가 Outer 체인을 따라 작동
3. 논리적 구조를 코드로 표현

- 자동 정리 과정

```
// 레벨 바뀔 때
GetWorld()->LoadLevel(TEXT("NewLevel"));

// 실제로는 이런 일들이 자동으로
// 1. 현재 Level의 모든 Actor들에게 "곧 사라진다" 알림
// 2. 각 Actor의 모든 Component들 정리
// 3. 각 Component의 모든 SubObject들 정리
// 4. Level 자체 삭제
// → 맵 전체가 깔끔하게 정리됨!
```

```
void APlayerCharacter::Die()
{
    Destroy();  // 플레이어가 죽을 때

    // 자동으로 정리되는 것들
    // - 인벤토리의 모든 아이템
    // - 장착한 모든 장비
    // - 활성화된 모든 스킬
    // - 캐릭터의 모든 컴포넌트
}
```

- NewObejct에서 Outer 지정

```
// NewObject의 기본 형태
UObject* NewObj = NewObject<UMyClass>(
    this,                    // ← 이 부분이 Outer (주인)
    UMyClass::StaticClass(), // 클래스 타입
    TEXT("ObjectName")       // 이름 (선택)
);

// 다양한 Outer 선택 예시
UObject* TempObj = NewObject<UObject>(GetTransientPackage());     // 임시 객체
UObject* WorldObj = NewObject<UObject>(GetWorld());              // 월드 레벨
UObject* GameObj = NewObject<UObject>(GetGameInstance());        // 게임 전체
UActorComponent* Comp = NewObject<UActorComponent>(MyActor);     // 액터 소유
```

- 자주 하는 실수들
1. 잘못된 Outer 선택

```
// 문제: UI를 액터가 소유하게 함
UUserWidget* Widget = NewObject<UUserWidget>(SomeActor);
// → 액터가 죽으면 UI도 사라짐!

// 해결: UI는 플레이어 컨트롤러가 소유
UUserWidget* Widget = NewObject<UUserWidget>(GetPlayerController());
// → 액터가 죽어도 UI는 유지됨
```

2. Outer 체인 끊기

```
// 위험: 중간 객체를 다른 곳으로 이동
UObject* Parent = NewObject<UObject>(this);
UObject* Child = NewObject<UObject>(Parent);

Parent->Rename(nullptr, SomeOtherObject);  // Parent를 다른 곳으로 이동
// → Child가 고아가 될 수 있음!
```


##### 생성, 수명, GC핵심

###### 생성 패턴 : `CreateDefaultSubobject` vs `NewObject`

- CreateDefaultSubobject - 미리 준비

```
class AMyActor : public AActor
{
    AMyActor()  // 생성자: 이 액터가 태어날 때 딱 한 번 실행
    {
        // "이 액터의 필수품들을 미리 준비해둬"
        MeshComponent = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("MeshComponent"));
        CollisionComponent = CreateDefaultSubobject<USphereComponent>(TEXT("Collision"));
    }

private:
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
    UStaticMeshComponent* MeshComponent;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
    USphereComponent* CollisionComponent;
};
```

- NewObject - 필요할 때

```
void AMyActor::OnLevelUp()  // 레벨업했을 때 호출되는 함수
{
    if (PlayerLevel >= 10)  // 10레벨 이상이면
    {
        // "지금 당장 특수능력을 만들어줘!"
        USpecialAbility* NewAbility = NewObject<USpecialAbility>(
            this,                           // 누가 주인? → 이 액터
            USpecialAbility::StaticClass(), // 어떤 타입?
            TEXT("FireballAbility")         // 이름은 뭐로 할까?
        );

        Abilities.Add(NewAbility);  // 능력 목록에 추가
    }
}
```

- 언제 무엇을 쓸까

| 구분         | CreateDefaultSubobject | NewObject      |
| ---------- | ---------------------- | -------------- |
| **사용 시점**  | 생성자에서만                 | 언제든지           |
| **목적**     | 기본 구성품 (필수)            | 동적 생성 (선택)     |
| **에디터 지원** | 완전 통합                  | 런타임 전용         |
| **예측 가능성** | 항상 같음                  | 상황마다 다름        |
| **사용 예시**  | 메시, 카메라, 기본 컴포넌트       | 아이템, 능력, 임시 객체 |

###### UObject 라이프 사이클

```
UCLASS()
class UMyObject : public UObject
{
    GENERATED_BODY()

public:
    // 1단계: "방금 태어났어요!"
    virtual void PostInitProperties() override
    {
        Super::PostInitProperties();  // 부모의 초기화부터 먼저!

        // 기본값 검증 및 보정
        if (SomeImportantValue <= 0)
        {
            SomeImportantValue = 100;  // 잘못된 값 보정
        }
    }

    // 2단계: "저장된 데이터를 불러왔어요!"
    virtual void PostLoad() override
    {
        Super::PostLoad();

        // 구버전 데이터를 신버전으로 변환
        if (DataVersion < CURRENT_VERSION)
        {
            UpgradeDataFormat();
        }
    }

    // 3단계: "곧 죽을 예정이에요..."
    virtual void BeginDestroy() override
    {
        // 다른 객체들에게 작별 인사
        NotifyOthersAboutMyDeath();

        Super::BeginDestroy();  // 부모의 정리 작업
    }

    // 4단계: "완전히 사라져요"
    virtual void FinishDestroy() override
    {
        // 마지막 정리 작업
        Super::FinishDestroy();
    }
};
```

- Super:: 호출의 중요성

```
// 이렇게 하면 큰일 납니다!
virtual void PostInitProperties() override
{
    // Super::PostInitProperties(); 생략함!
    MyCustomInitialization();
    // → 언리얼 엔진의 기본 초기화가 안 됨!
}

// 올바른 방법
virtual void PostInitProperties() override
{
    Super::PostInitProperties();  // 부모의 초기화 먼저
    MyCustomInitialization();    // 그 다음에 내 초기화
}
```

- GetWorld() 사용법

```
// 이렇게 하면 큰일 납니다!
virtual void PostInitProperties() override
{
    // Super::PostInitProperties(); 생략함!
    MyCustomInitialization();
    // → 언리얼 엔진의 기본 초기화가 안 됨!
}

// 올바른 방법
virtual void PostInitProperties() override
{
    Super::PostInitProperties();  // 부모의 초기화 먼저
    MyCustomInitialization();    // 그 다음에 내 초기화
}
```


###### GC 동작 원리 : Mark & Sweep

- GC 작업 과정

```
게임 상황: 플레이어가 무기를 버렸다

시작 상태:
[World] → [PlayerController] → [PlayerCharacter] → [InventoryComponent]
                                                  ↘
                                                   [WeaponItem] → [WeaponMesh]

무기를 버린 후:
[World] → [PlayerController] → [PlayerCharacter] → [InventoryComponent]

                              (연결 끊어짐)

                                                   [WeaponItem] → [WeaponMesh]

GC 실행:
1. Mark 단계:
   - World부터 시작 ✓
   - PlayerController 표시 ✓
   - PlayerCharacter 표시 ✓
   - InventoryComponent 표시 ✓
   - WeaponItem은 아무도 참조 안 함 → 표시 없음 ✗
   - WeaponMesh도 표시 없음 ✗

2. Sweep 단계:
   - WeaponItem 삭제
   - WeaponMesh 삭제
```


###### UPROPERTY의 진실 : GC가 보는 것과 못 보는 것

- 왜 UPROPERTY를 볼까
1. 성능 때문

```
class UMyComplexObject : public UObject
{
    // UObject 포인터들 (GC가 관심있어 함)
    UObject* Obj1;
    UObject* Obj2;

    // 일반 C++ 타입들 (GC가 관심없음)
    int32 SomeNumber;
    float SomeFloat;
    FString SomeString;
    TArray<int32> NumberArray;

    // 외부 라이브러리 타입들 (GC가 알 수 없음)
    std::vector<int> CppVector;
    std::shared_ptr<SomeClass> SharedPtr;

    // 그 외 수십, 수백 개의 변수들...
};
```

2. 타입 안전성 때문

```
class UConfusingObject : public UObject
{
    void* VoidPointer;          // 이게 뭘 가리키는지 알 수 없음
    int32* IntPointer;          // int를 가리키는 포인터
    UObject* ObjectPointer;     // UObject를 가리키는 포인터

    // GC는 이 중에서 뭘 체크해야 할까요?
    // → ObjectPointer만 체크하면 됨!
    // → 하지만 그걸 어떻게 구분할까?
    // → UPROPERTY로 표시하면 확실!
};
```

3. 의도 파악 때문

```
class UIntentionExample : public UObject
{
    UObject* ImportantReference;    // 이건 중요한 참조일까? 임시일까?
    UObject* TemporaryPointer;      // 잠깔 쓰고 버릴 포인터일까?
    UObject* CachePointer;          // 성능을 위한 캐시일까?

    // 개발자만이 각 포인터의 의도를 알고 있음
    // UPROPERTY = "이건 중요하니까 GC가 신경써줘"
    // UPROPERTY 없음 = "이건 임시니까 신경 안 써도 돼"
};
```

- UPROPERTY 있음 vs. 없음

```
UCLASS()
class UGCTestObject : public UObject
{
    GENERATED_BODY()

public:
    // UPROPERTY 있음 - GC가 보호함
    UPROPERTY()
    UObject* SafeReference;

    UPROPERTY()
    TArray<UObject*> SafeArray;

    // UPROPERTY 없음 - GC가 모름
    UObject* UnsafeReference;
    TArray<UObject*> UnsafeArray;

    void TestTheReferences()
    {
        // 테스트용 객체들 생성
        UObject* TestObj1 = NewObject<UObject>(this);
        UObject* TestObj2 = NewObject<UObject>(this);

        // 참조 설정
        SafeReference = TestObj1;     // GC가 TestObj1을 보호
        UnsafeReference = TestObj2;   // GC가 TestObj2를 모름!

        // 잠시 후 GC 실행되면...
        // TestObj1 → 살아남음
        // TestObj2 → 삭제됨!
    }
};
```

- 다양한 UPROPERTY 적용 사례
1. 기본 참조들

```
class UBasicReferences : public UObject
{
    UPROPERTY()
    UObject* SingleObject;              // 단일 객체 참조

    UPROPERTY()
    TArray<UObject*> ObjectArray;       // 배열 참조 (배열 안의 모든 객체 보호됨)

    UPROPERTY()
    TMap<FString, UObject*> ObjectMap;  // 맵 참조 (Value 객체들만 보호됨)
};
```

2. 구조체 안의 참조도 보호됨

```
USTRUCT()
struct FMyStruct
{
    GENERATED_BODY()

    UPROPERTY()
    UObject* NestedObject;  // 구조체 안의 참조도 GC가 봄!
};

UCLASS()
class UStructContainer : public UObject
{
    UPROPERTY()
    FMyStruct MyStruct;  // 구조체 전체를 UPROPERTY로 하면
                         // 구조체 안의 UObject 참조들도 모두 보호됨!
};
```

- UPROPERTY 없는 참조 안전하게 다루기

```
class UAdvancedUsage : public UObject
{
    // 이런 것들은 UPROPERTY가 안 됨
    TSharedPtr<FMyData> SharedData;           // 스마트 포인터
    std::unique_ptr<SomeClass> UniquePtr;     // C++ 스마트 포인터

public:
    // 방법 1: 수명을 명확히 관리
    void SafeUsagePattern()
    {
        auto Data = MakeShared<FMyData>();
        SharedData = Data;

        ProcessData(SharedData.Get());  // 이 함수 안에서만 사용

        SharedData.Reset();  // 명시적 해제
    }

    // 방법 2: BeginDestroy에서 정리
    virtual void BeginDestroy() override
    {
        SharedData.Reset();     // 죽기 전에 모든 포인터 정리
        UniquePtr.reset();

        Super::BeginDestroy();
    }
};
```


##### AddToRoot : 강력하지만 위험한 최후의 수단

- 올바른 사용법
1. 싱글톤

```
// 게임 전체에서 하나만 존재해야 하는 매니저
class USoundManager : public UObject
{
    static USoundManager* Instance;

public:
    static USoundManager* GetInstance()
    {
        if (!Instance)
        {
            Instance = NewObject<USoundManager>(GetTransientPackage());
            Instance->AddToRoot();  // Root에 추가 → 게임이 끝날 때까지 보존
        }
        return Instance;
    }

    static void Shutdown()
    {
        if (Instance)
        {
            Instance->RemoveFromRoot();  // Root에서 제거 (중요!)
            Instance = nullptr;
        }
    }
};

// 게임 종료 시 - 반드시 호출해야 함!
void UMyGameInstance::Shutdown()
{
    USoundManager::Shutdown();  // 수동으로 정리
    Super::Shutdown();
}
```

2. 비동기 작업 보호

```
// 비동기 로딩 중에는 삭제되면 안 되는 객체
class UAssetLoader : public UObject
{
public:
    void LoadAssetAsync(const FSoftObjectPath& AssetPath)
    {
        AddToRoot();    // 로딩 시작 전에 자신을 보호
        bIsLoading = true;

        // 비동기 로딩 시작
        UAssetManager& AssetManager = UAssetManager::Get();
        StreamableHandle = AssetManager.LoadAssetAsync(AssetPath,
            FStreamableDelegate::CreateUObject(this, &UAssetLoader::OnLoadComplete)
        );
    }

private:
    void OnLoadComplete()
    {
        bIsLoading = false;
        RemoveFromRoot();  // 로딩 완료 → 보호 해제

        // 이제 이 객체는 필요없으면 GC가 정리할 수 있음
    }
};
```

3. 임시 보호

```
// 위험한 작업 중 임시 보호
void RiskyOperation(UObject* ImportantObject)
{
    ImportantObject->AddToRoot();       // 위험한 작업 전에 임시 보호

    LoadSomeHeavyAssets();              // GC 유발 가능한 작업들
    CreateThousandsOfObjects();
    CallComplexBlueprintFunction();

    ImportantObject->RemoveFromRoot();  // 작업 완료 즉시 보호 해제
}

```

- 위험한 사용 패턴들
1. RemoveFromRoot 없는 무한 보존

```
// 이렇게 하면 메모리 누수!
class UBadManager : public UObject
{
public:
    void CreateImportantData()
    {
        UObject* Data = NewObject<UObject>(this);
        Data->AddToRoot();  // Root에 추가

        ImportantData.Add(Data);

        // 문제: 언제 RemoveFromRoot()를 할지 정하지 않음!
        // 결과: 이 객체는 게임이 끝날 때까지 메모리에 영원히 남음
    }
};
```

2. 불필요한 Root 추가

```
// 이미 보호받는 객체에 또 Root 추가
class AMyActor : public AActor
{
public:
    void BeginPlay() override
    {
        Super::BeginPlay();

        AddToRoot();  // 잘못된 생각: "혹시 몰라서 Root에 추가하자"

        // 문제: Actor는 이미 World가 Root 역할을 함!
        // 중복 보호 = 불필요한 성능 낭비 + 복잡성 증가
    }
};
```

- 더 좋은 대안들
1. UPROPERTY 사용 (95% 상황에서 최선)

```
// 대안 1: UPROPERTY 사용
class UGoodManager : public UObject
{
    UPROPERTY()  // AddToRoot 없이도 안전하게 관리
    TArray<UObject*> ManagedObjects;

public:
    void AddManagedObject(UObject* NewObj)
    {
        ManagedObjects.Add(NewObj);  // UPROPERTY로 충분히 보호됨
    }
};
```

2. Outer 관계 활용

```
// 대안 2: Outer 관계 활용
class UDataContainer : public UObject
{
public:
    UObject* CreateSubData(TSubclassOf<UObject> DataClass)
    {
        // this가 Outer → Container가 사라지면 SubData도 자동 정리
        return NewObject<UObject>(this, DataClass);
    }
};
```

3. 게임 인스턴스나 월드에 등록

```
// 대안 3: 게임 인스턴스나 월드에 등록
class UGlobalDataManager : public UObject
{
public:
    static UGlobalDataManager* CreateInstance(UGameInstance* GameInstance)
    {
        // GameInstance가 Outer → 게임이 끝날 때까지 보존
        return NewObject<UGlobalDataManager>(GameInstance);
        // AddToRoot() 불필요! GameInstance가 이미 Root이므로 자동 보호
    }
};
```


##### 참조 관리 기초

###### Hard vs Week : 선택 규칙과 안전 패턴

- Hard Reference (강한 참조)

```
UCLASS()
class UInventory : public UObject
{
    GENERATED_BODY()

public:
    // 이게 Hard Reference (강한 참조)
    UPROPERTY()
    TArray<UObject*> Items;  // UObject* = 일반 포인터 = Hard
};
```

```
UInventory* Inventory = NewObject<UInventory>();
UItem* Sword = NewObject<UItem>();

Inventory->Items.Add(Sword);  // Inventory가 Sword를 "소유"
// 이제 Sword는 Inventory가 살아있는 한 절대 삭제되지 않음
```

- Week Reference (약한 참조)

```
UCLASS()
class UItemWidget : public UObject
{
    GENERATED_BODY()

public:
    // 이게 Weak Reference (약한 참조)
    UPROPERTY()
    TWeakObjectPtr<AActor> ObservedActor;  // TWeakObjectPtr = Weak

    void UpdateDisplay()
    {
        // Weak 참조는 항상 유효성 체크 필수!
        if (ObservedActor.IsValid())  // "아직 살아있나?"
        {
            AActor* Actor = ObservedActor.Get();  // 실제 포인터 가져오기
            FString Name = Actor->GetName();      // 이제 안전하게 사용
        }
        else
        {
            // 대상이 이미 삭제됨 → UI를 비우거나 기본값 표시
        }
    }
};
```

- 사용법 비교

```
// Hard Reference 체크
UPROPERTY()
AActor* MyActor;

void CheckHardRef()
{
    if (IsValid(MyActor))  // 전역 함수 IsValid()
    {
        MyActor->DoSomething();  // 바로 사용 가능
    }
}

// Weak Reference 체크
UPROPERTY()
TWeakObjectPtr<AActor> MyActorWeak;

void CheckWeakRef()
{
    if (MyActorWeak.IsValid())  // 멤버 함수 IsValid()
    {
        AActor* Actor = MyActorWeak.Get();  // Get()으로 포인터 획득
        Actor->DoSomething();               // 이제 안전하게 사용
    }
}
```


###### 실제 게임 상황에서의 선택 기준

- 전형적인 소유 관계 (Hard)

```
// 인벤토리 시스템
class UInventory : public UObject
{
    UPROPERTY()
    TArray<UItem*> Items;  // Hard: 인벤토리가 아이템들을 소유
};

// 스킬 시스템
class USkillManager : public UObject
{
    UPROPERTY()
    TArray<USkill*> LearnedSkills;  // Hard: 매니저가 스킬들을 관리
};
```

- 전형적인 관찰 관계 (Week)

```
// UI 시스템
class UHealthBarWidget : public UUserWidget
{
    UPROPERTY()
    TWeakObjectPtr<ACharacter> WatchedCharacter;  // Weak: UI는 관찰만 함
};

// 미니맵 시스템
class UMinimapWidget : public UUserWidget
{
    UPROPERTY()
    TWeakObjectPtr<APawn> TrackedPlayer;  // Weak: 추적만 함
};

```


###### 자주 하는 실수들

1. UPROPERTY 없는 생 포인터

```
// 절대 금지! - GC가 모르는 포인터
class UBadExample : public UObject
{
    UObject* DangerousPtr;  // UPROPERTY 없음 = 크래시 위험!
};
```

2. Week 참조를 체크 없이 사용

```
// 위험한 코드 - 삭제된 객체에 접근할 수 있음
void BadWeakUsage()
{
    AActor* Actor = WeakPtr.Get();  // IsValid() 체크 없이 바로 Get()
    Actor->DoSomething();  // 💥 크래시 가능성!
}

// 올바른 코드 - 항상 체크 후 사용
void GoodWeakUsage()
{
    if (WeakPtr.IsValid())  // 먼저 살아있는지 확인
    {
        AActor* Actor = WeakPtr.Get();
        Actor->DoSomething();  // 안전
    }
}
```

3. 모든 걸 Hard로 하기


##### 순환 참조 차단 : 메모리 누수의 주범을 막자

- 문제 : 순환 참조

```
// 순환 참조 - 재앙의 시작
class UParent : public UObject
{
    UPROPERTY()
    UChild* Child;  // Parent가 Child를 Hard 참조
};

class UChild : public UObject
{
    UPROPERTY()
    UParent* Parent;  // Child도 Parent를 Hard 참조 (문제!)
};
```

```
Parent ─(강한 참조)→ Child
  ↑                    ↓
  └──(강한 참조)───────┘

"나는 저 애가 있어야 살 수 있어!"
"나도 저 애가 있어야 살 수 있어!"
결과: 둘 다 영원히 메모리에서 안 사라짐
```

- 해결법
1. 한쪽을 Week로

```
// 올바른 코드 - 순환 참조 해결!
UCLASS()
class UParent : public UObject
{
    GENERATED_BODY()
public:
    UPROPERTY()
    UChild* Child;  // Parent → Child는 Hard (소유)

    void CreateChild()
    {
        Child = NewObject<UChild>(this);
        Child->SetParent(this);  // 자식에게 부모 알려주기
    }
};

UCLASS()
class UChild : public UObject
{
    GENERATED_BODY()
public:
    UPROPERTY()
    TWeakObjectPtr<UParent> Parent;  // Child → Parent는 Weak (역참조)

    void SetParent(UParent* NewParent)
    {
        Parent = NewParent;
    }

    void DoSomethingWithParent()
    {
        if (Parent.IsValid())  // 항상 체크!
        {
            UParent* P = Parent.Get();
            // 안전하게 부모 사용
        }
    }
};
```

```
Parent ─(강한 참조)→ Child
  ↑                    ↓
  └──(약한 참조)───────┘

Parent: "나는 Child를 소유하고 책임진다"
Child: "Parent를 지켜보긴 하지만 붙잡고 있지는 않아"
결과: Parent가 필요없어지면 Child도 함께 정리됨
```

- 실제 게임 예시들

```
// 인벤토리 시스템
class UInventory : public UObject
{
    UPROPERTY()
    TArray<UItem*> Items;  // Hard: 인벤토리가 아이템 소유
};

class UItem : public UObject
{
    UPROPERTY()
    TWeakObjectPtr<UInventory> OwnerInventory;  // Weak: 아이템이 소유자 참조
};
```

```
// UI 시스템
class UPlayerHUD : public UUserWidget
{
    UPROPERTY()
    TArray<UWidget*> ChildWidgets;  // Hard: HUD가 자식 위젯들 소유
};

class UHealthBar : public UUserWidget
{
    UPROPERTY()
    TWeakObjectPtr<UPlayerHUD> ParentHUD;  // Weak: 자식이 부모 참조
};
```

2. 인터페이스로 의존성 줄이기

```
// 1. 인터페이스 정의 - "체력을 가진 것"
UINTERFACE()
class UHealthOwner : public UInterface
{
    GENERATED_BODY()
};

class IHealthOwner
{
    GENERATED_BODY()
public:
    virtual float GetHealth() const = 0;
    virtual void TakeDamage(float Damage) = 0;
};

// 2. 캐릭터가 인터페이스 구현
UCLASS()
class AMyCharacter : public AActor, public IHealthOwner
{
    GENERATED_BODY()

    float Health = 100.0f;

public:
    virtual float GetHealth() const override { return Health; }
    virtual void TakeDamage(float Damage) override { Health -= Damage; }
};

// 3. UI가 인터페이스로 소통
UCLASS()
class UHealthBar : public UUserWidget
{
    GENERATED_BODY()

    UPROPERTY()
    TWeakObjectPtr<UObject> Target;  // 구체적인 타입을 모름!

public:
    void UpdateHealthBar()
    {
        if (!Target.IsValid()) return;

        UObject* Obj = Target.Get();

        // 인터페이스를 구현했는지 확인
        if (Obj->GetClass()->ImplementsInterface(UHealthOwner::StaticClass()))
        {
            // 인터페이스를 통해 소통
            IHealthOwner* HealthOwner = Cast<IHealthOwner>(Obj);
            float CurrentHealth = HealthOwner->GetHealth();
            // UI 업데이트...
        }
    }
};
```

3. 델리게이트로 이벤트 기반 소통

```
class UEventSender : public UObject
{
    DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnHealthChanged, float, NewHealth);

    UPROPERTY(BlueprintAssignable)
    FOnHealthChanged OnHealthChanged;

    void ChangeHealth(float NewHealth)
    {
        OnHealthChanged.Broadcast(NewHealth);  // 이벤트 발생
    }
};

class UEventReceiver : public UObject
{
public:
    void StartListening(UEventSender* Sender)
    {
        if (Sender)
        {
            // 이벤트 바인딩
            Sender->OnHealthChanged.AddDynamic(this, &UEventReceiver::OnHealthChanged);
        }
    }

    virtual void BeginDestroy() override
    {
        // 중요: 죽기 전에 반드시 언바인딩!
        if (EventSender && IsValid(EventSender))
        {
            EventSender->OnHealthChanged.RemoveDynamic(this, &UEventReceiver::OnHealthChanged);
        }

        Super::BeginDestroy();
    }

    UFUNCTION()
    void OnHealthChanged(float NewHealth)
    {
        // 이벤트 처리
    }

private:
    UPROPERTY()
    TWeakObjectPtr<UEventSender> EventSender;  // Weak 참조로 저장
};
```


##### 핵심 원칙 4가지

1. UPROPERTY는 메모리 관리의 기본
	- Actor든 Component든 UObject 참조는 **반드시 UPROPERTY**
	- 배열, 맵 등 컨테이너도 **UPROPERTY 필수**
2. 소유하면 Hard, 관찰하면 Week
	- 인벤토리 -> 아이템 : **Hard** (소유)
	- UI -> 캐릭터 : **Week** (관찰)
	- 매니저 -> 관리대상 : **Hard** (책임)
3. 생명주기 함수에서 정리하기
	- **BeginPlay** : 초기화, 연결 설정
	- **EndPlay** : 타이머 정리, 델리게이트 언바인딩
	- **Destroyed** : 마지막 정리 작업
4. 동적 생성은 5단계 과정
	- NewObject (Outer 설정)
	- 속성 설정
	- RegisterComponent() (필수!)
	- AttachToComponent (부착)
	- UPROPERTY 배열에 추가 (GC 보호)