---
title: GoF 디자인 패턴2
description: 행동 패턴
author: gemini
date: 2025-08-07 19:00:00 +09:00
categories: [Unreal]
tags: [GoF]
math: true
mermaid: true
---

#### 행동 패턴 (Behavioral Patterns)

##### 옵저버 패턴 (Observer Pattern) - 이벤트 시스템의 핵심

- 개념
	- 객체의 상태변화를 관찰하던 객체들에게 자동으로 알림을 보내는 패턴
	- 1:N 의존 관계를 정의하여 한 객체의 상태가 변하면 모든 의존 객체들이 알림을 받고 자동으업데이트 됨
- 언제 필요?
	- 플레이어 체력이 변할 때, UI, 사운드, 이펙트가 동시에 반응해야 할 때
	- 게임 상태 변화를 여러 시스템이 감지해야 할 때
	- 느슨한 결합을 유지하면서 이벤트를 전파하고 싶을 때
	- MVC 패턴에서 모델의 변화를 뷰에 알려야 할 때

- Observer 패턴 구조
1. Subject 인터페이스

```
class IHealthObserver {
public:
    virtual void OnHealthChanged(float health) = 0;
};
```

2. Concrete Subject (Player)

```
class Player {
private:
    float health = 100.0f;
    vector<IHealthObserver*> observers;
    
public:
    void AttachObserver(IHealthObserver* obs) {
        observers.push_back(obs);
    }
    
    void NotifyHealthChanged() {
        for (auto obs : observers) {
            obs->OnHealthChanged(health);
        }
    }
    
    void TakeDamage(float damage) {
        health -= damage;
        NotifyHealthChanged(); // 모든 관찰자에게 자동 알림!
    }
};
```

3. Concrete Obervers

```
class HealthBarUI : public IHealthObserver {
public:
    void OnHealthChanged(float health) override {
        cout << "UI: Health updated to " << health << endl;
    }
};

class AudioObserver : public IHealthObserver {
public:
    void OnHealthChanged(float health) override {
        if (health < 20) cout << "Audio: Low health warning!" << endl;
    }
};
```

4. 사용 방법

```
Player player;
HealthBarUI ui;
AudioObserver audio;

player.AttachObserver(&ui);
player.AttachObserver(&audio);

player.TakeDamage(30); // UI와 Audio가 자동으로 반응!
```

- 사용 가이드라인
	- 적합한 경우
		- 플레이어 상태 변화 : 체력, 마나, 경험치 변화 시 여러 UI 요소가 동시에 업데이트
		- 이벤트 기반 시스템 : 아이템 획득, 퀘스트 완료, 레벨업 등의 이벤트 발생 시
		- 실시간 알림 : 길드 채팅, 친구 접속, 경매장 알림 등
		- 성취/업적 시스템 : 특정 조건 달성 시 여러 시스템이 반응해야 할 때
	- 피해야 할 경우
		- 성능 문제 상황
			- 극도로 빈번한 호출 : 매 프레임 발생하는 이벤트 (예. 마우스 이동)
			- 대량의 관찰자 : 수천 개의 Observer가 등록된 경우
			- 복잡한 알림 로직 : Observer 내부에서 무거운 연산을 수행하는 경우
			- 체인 반응 : Observer가 또 다른 이벤트를 발생시켜 무한 루프 위험
		- 단순한 상황
			- 1:1 관계 : 오직 하나의 객체만 반응하는 경우
			- 직접 호출이 간단 : `healthBar->Update()` 한 줄로 충분한 경우
			- 즉시 처리 필요 : 이벤트 발생과 동시에 즉시 처리되어야 하는 경우


##### 커맨드 패턴 (Command Pattern) - 행동의 캡슐화

- 개념
	- 요청을 객체로 캡슐화하여 매개변수로 전달하고, 요청을 큐에 저장하거나 로그를 남기고, 실행 취소를 지원할 수 있게 하는 패턴
- 언제 필요?
	- 플레이어 행동을 되돌리기 (Undo) 기능이 필요할 때
	- 키 바인딩을 동적으로 변경하고 싶을 때
	- 행동을 큐에 저장해서 순차 실행하고 싶을 때
	- 매크로나 리플레이 시스템을 만들 때
	- AI의 행동을 계획하고 실행할 때

- Commad 패턴 구조
1. Command 인터페이스

```
class ICommand {
public:
    virtual void Execute() = 0;
    virtual void Undo() = 0;
};
```

2. Receiver (실제 작업을 수행하는 객체)

```
class Player {
public:
    int x = 0, y = 0;
    void MoveUp() { y++; }
    void MoveDown() { y--; }
};
```

3. Concrete Commands

```
class MoveUpCommand : public ICommand {
private:
    Player* player;
    
public:
    MoveUpCommand(Player* p) : player(p) {}
    
    void Execute() override { player->MoveUp(); }
    void Undo() override { player->MoveDown(); }
};
```

4. Invoker (커맨드 실행자)

```
class CommandManager {
private:
    vector<ICommand*> history;
    int currentIndex = -1;
    
public:
    void ExecuteCommand(ICommand* cmd) {
        cmd->Execute();
        history.push_back(cmd);
        currentIndex++;
    }
    
    void Undo() {
        if (currentIndex >= 0) {
            history[currentIndex]->Undo();
            currentIndex--;
        }
    }
};
```

5. 사용 방법

```
Player player;
CommandManager cmdManager;

auto moveCmd = new MoveUpCommand(&player);
cmdManager.ExecuteCommand(moveCmd); // 실행
cmdManager.Undo();                  // 되돌리기!
```

- 사용 가이드라인
	- 적합한 경우
		- 실행 취소/재실행 : 턴제 게임, 퍼즐 게임, 레벨 에디터
		- 매크로 시스템 : 복잡한 조작을 하나의 버튼으로 실행
		- 리플레이 기능 : 플레이어 행동을 기록하고 재생
		- 키 바인딩 : 사용자가 키 설정을 자유롭게 변경
	- 피해야 할 경우
		- 성능 중시 상황
			- 실시간 액션 게임 : 즉시 반응이 필요한 조작 (점프, 공격)
			- 물리 연산 : 매 프레임 실행되는 물리 시뮬레이션
			- 렌더링 명령 : 그래픽 카드에 직접 전달되는 명령들
			- 메모리 제약 : 모바일 등 메모리가 극도로 제한적인 환경
		- 단순한 기능
			- 일회성 실행 : 되돌리기가 불필요한 간단한 기능
			- 상태 없음 : 매개변수가 없는 단순한 메서드 호출
			- 즉시 실행만 : 큐잉이나 지연 실행이 불필요한 경우


##### 상태 패턴 (State Pattern) - AI와 게임 상태

- 개념
	- 객체의 내부 상태가 변할 때, 객체의 행동도 함께 변하도록 하는 패턴, 상태를 별도의 클래스캡슐화하고 위임을 통해 행동을 변경
- 언제 필요?
	- AI 캐릭터의 상태 (Idle, Patrol, Chase, Attack)가 복잡할 때
	- 게임 상태 (Menu, Playing, Paused, GameOver)를 관리할 때
	- 플레이어 상태 (Normal, Stunned, Invisible, Flying)에 따라 행동이 달라질 때
	- 복잡한 if-else 문을 깔금하게 정리하고 싶을 때

- State 패턴 구조
1. State 인터페이스와 Context

```
class IEnemyState {
public:
    virtual void Update(class Enemy* enemy) = 0;
};

class Enemy {
private:
    IEnemyState* currentState;
    
public:
    void ChangeState(IEnemyState* newState) {
        delete currentState;
        currentState = newState;
    }
    
    void Update() {
        if (currentState) currentState->Update(this);
    }
    
    bool SeePlayer() { return true; }  // 임시
    bool NearPlayer() { return true; } // 임시
};
```

2. Concrete State

```
class IdleState : public IEnemyState {
public:
    void Update(Enemy* enemy) override {
        cout << "Idling..." << endl;
        if (enemy->SeePlayer()) {
            enemy->ChangeState(new ChaseState());
        }
    }
};

class ChaseState : public IEnemyState {
public:
    void Update(Enemy* enemy) override {
        cout << "Chasing player!" << endl;
        if (enemy->NearPlayer()) {
            enemy->ChangeState(new AttackState());
        }
    }
};

class AttackState : public IEnemyState {
public:
    void Update(Enemy* enemy) override {
        cout << "Attacking!" << endl;
    }
};
```

3. 사용 방법

```
Enemy enemy;
enemy.ChangeState(new IdleState());

for (int i = 0; i < 10; i++) {
    enemy.Update(); // 상태에 따라 다른 행동!
}
```

- 사용 가이드라인
	- 적합한 경우
		- NPC 행동 : Idle -> Patrol -> Alert -> Attack -> Flee
		- 몬스터 AI : 평상시, 경계, 추적, 공격, 도망, 사망
		- 보스 패턴 : 페이즈 별로 완전히 다른 행동 패턴
		- 동물 AI : 배고픔, 목마름, 수면, 경계 등 복합 상태
	- 피해야 할 경우
		- 단순한 상태
			- 2-3개의 단순 상태 : boolean 변수로도 충분한 경우
			- 상태 전환이 거의 없음 : 초기 설정 후 변경이 드문 경우
			- 로직이 매우 단순 : 각 상태에서 하는 일이 한두 줄인 경우
		- 성능이 중요한 경우
			- 매 프레임 실행 : 물리 연산처럼 극도로 빈번한 호출
			- 대량의 객체 : 수천 개의 객체가 각각 상태를 가지는 경우
			- 실시간 처리 : 지연이 허용되지 않는 시스템


##### 전략 패턴 (Strategy Pattern) - 알고리즘의 자유로운 교체

- 개념
	- 동일한 문제를 해결하는 여러 알고리즘을 캡슐화하고, 런타임에 알고리즘을 선택할 수 있게 하는 패턴. 알고리즘의 변경이 클라이언트에 영향을 주지 않음
- 언제 필요?
	- AI의 행동 패턴을 동적으로 바꾸고 싶을 때
	- 난이도에 따라 적의 움직임이 달라져야 할 때
	- 무기마다 다른 공격 패턴을 가져야 할 때
	- 정렬, 탐색 등의 알고리즘을 상황에 맞게 선택하고 싶을 때

- Strategy 패턴 구조
1. Strategy 인터페이스

```
class IMovementStrategy {
public:
    virtual void Execute(class GameCharacter* character) = 0;
};
```

2. Context 클래스

```
class GameCharacter {
private:
    IMovementStrategy* movementStrategy;
    
public:
    void SetMovementStrategy(IMovementStrategy* strategy) {
        delete movementStrategy;
        movementStrategy = strategy;
    }
    
    void Move() {
        if (movementStrategy) {
            movementStrategy->Execute(this);
        }
    }
};
```

3. Concrete Strategies

```
class AggressiveMovement : public IMovementStrategy {
public:
    void Execute(GameCharacter* character) override {
        cout << "Moving aggressively towards player!" << endl;
        // 플레이어를 향해 빠르게 이동
    }
};

class DefensiveMovement : public IMovementStrategy {
public:
    void Execute(GameCharacter* character) override {
        cout << "Moving defensively, keeping distance" << endl;
        // 거리를 유지하며 이동
    }
};

class RandomMovement : public IMovementStrategy {
public:
    void Execute(GameCharacter* character) override {
        cout << "Moving randomly" << endl;
        // 랜덤한 방향으로 이동
    }
};
```

4. 사용 방법

```
GameCharacter enemy;

// 전략 변경
enemy.SetMovementStrategy(new AggressiveMovement());
enemy.Move(); // "Moving aggressively towards player!"

enemy.SetMovementStrategy(new DefensiveMovement());
enemy.Move(); // "Moving defensively, keeping distance"
```

- 사용 가이드라인
	- 적합한 경우
		- 게임 AI 다양성
			- AI 행동 패턴 : 공격적, 수비적, 균형잡힌 등 다양한 성향
			- 난이도별 AI : 같은 캐릭터라도 난이도에 따라 다른 전략
			- 상황 적응 AI : 플레이어 플레이 스타일에 따라 전략 변경
			- 팀 전술 : 상황에 따라 공격, 수비, 밸런스 전술 전환
		- 전투 시스템
			- 무기별 공격 패턴 : 검, 활, 마법 등 각각 다른 공격 방식
			- 스킬 발동 조건 : 체력, 마나, 상황에 따른 다른 스킬 선택
			- 방어 전략 : 방패, 회피, 반격 등 다양한 방어 방식
			- 버프/디버프 : 상황에 맞는 최적의 버프 선택
	- 피해야 할 경우
		- 단일 알고리즘
			- 고정된 로직 : 항상 같은 방식으로만 처리되는 경우
			- 변경 불필요 : 런타임에 전략을 바꿀 필요가 없는 경우
			- 단순한 분기 : if-else 한두 개로 충분한 경우
			- 성능이 최우선 : 함수 포인터 직접 호출이 더 빠른 경우
		- 과도한 추상화
			- 과도한 복잡성 : 전략 패턴으로 인해 코드가 더 복잡해지는 경우
			- 이해하기 어려움 : 팀원들이 이해하기 어려운 수준의 추상화
			- 디버깅 어려움 : 어떤 전략이 실행되는지 추적하기 어려운 경우


#### 패턴 선택의 현실적 기준

- 이론상 선택 기준
1. 요구사항 분석
2. 확장성 고려
3. 유지보수성 검토
4. 팀 역량 평가
5. 성능 영향 분석

- 실제 선택 기준
1. "예전에 써봤는데 괜찮았어"
2. "시니어가 쓰라고 했어"
3. "일단 돌아가면 되지 뭐"
4. "데드라인이 내일이야"


#### 패턴 마스터로 가는 길

##### 짭 패턴 마스터의 특징
1. 패턴 이름만 안다
2. 무조건 패턴을 쓴다
3. 복잡할수록 좋다고 생각한다
4. 성능은 무시한다

##### 찐 패턴 마스터의 특징
1. 패턴을 안 쓸 줄 안다
2. 패턴을 변형할 줄 안다
3. 패턴의 한계를 안다
4. 팀을 고려한다
5. 성능을 고려한다


#### 개발자가 추구해야할 마음가짐

- 패턴은 도구다. 목적이 아니다
- 단순함이 복잡함보다 낫다
- 동료가 이해할 수 있어야 한다
- 성능도 중요하다
- 완벽한 코드는 없다