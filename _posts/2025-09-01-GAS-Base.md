---
title: GAS 기본 구조
description: GAS 기본 구조
author: gemini
date: 2025-09-01 19:00:00 +09:00
categories: [Unreal]
tags: [GAS]
math: true
mermaid: true
---

#### GAS란?

- Game Ability System
- Epic Games에서 포트나이트 개발 시 만든 시스템
- 스킬, 버프, 능력치를 체계적으로 관리하는 프레임 워크
- 전통적인 RPG 캐릭터 시트 - GAS는 이것을 디지털로 구현한 것
	- 이름 : 전사
	- 체력 : 100/120 <- Attribute
	- 마나 : 50/80
	- 스킬 : 검격, 방패 <- Ability
	- 상태 : 독, 축복 <- Effect


#### ASC (AbilitySystemComponent) - 지휘관

```
    ┌─── Player Input ───┐
    │   (스킬 키 누름)    │
    └──────┬─────────────┘
           │
    ┌──────▼─────────────┐
    │  AbilitySystem     │
    │   Component        │  ← 모든 것의 중심!
    │  (지휘관 역할)      │
    └──┬──────────────┬──┘
       │              │
  ┌────▼───┐     ┌───▼────┐
  │Ability │     │Effect  │
  │ 관리    │     │관리    │
  └────┬───┘     └───┬────┘
       │             │
  ┌────▼─────────────▼────┐
  │   AttributeSet        │
  │ (실제 수치 저장소)     │
  └───────────────────────┘
```

```
UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category="GAS")
class UAbilitySystemComponent* AbilitySystemComponent;
```

- 역할
	- Ability 실행 관리
	- Attribute 변경 추적
	- Effect 적용/제거
	- 네트워크 동기화
	- 게임 마스터 (GM)
		- 플레이어 : "파이어볼을 쓰고 싶어요!"
		- GM (ASC) : "마나가 충분한가요? 쿨다운은 끝났나요?"
		- GM (ASC) : "조건 만족! 마나 30 차감하고 데미지 굴러보세요"


#### Attribute - 캐릭터의 수치 데이터

```
// 전통적인 방식 - 문제투성이
class AMyCharacter 
{
    float Health = 100.0f;
    
    void TakeDamage(float Damage)
    {
        Health -= Damage;  // 너무 단순함!
        
        // 문제들:
        // 1. 방어력은 어떻게 계산?
        // 2. 버프/디버프는?
        // 3. 크리티컬은?
        // 4. 네트워크 동기화는?
        // 5. UI 업데이트는?
    }
};
```

```
FGameplayAttributeData Health;  // 단순한 float가 아님!

// 내부적으로 이런 식으로 동작:
Health.BaseValue = 100;           // 기본 체력
+ 장비 버프 = +30                 // Infinite Effect
+ 임시 버프 = +20                 // Duration Effect  
+ 포션 효과 = +10                 // Duration Effect
= Health.CurrentValue = 160      // 최종 계산값
```

- 왜 FGameplayAttributeData를 쓸까
	- Base Value : 기본값 (레벨업, 장비로 영구 변경)
	- Current Value : 현재값 (버프/디버프로 임시 변경)
	- 자동 계산 : Current = Base + 모든 버프/디버프

- Attribute 계산 과정

```
Health 계산 과정

BaseValue: 100
    │
    ├─ Add Modifiers (더하기)
    │   ├─ 힘 훈련: +20
    │   ├─ 장비 보너스: +30
    │   └─ 독 디버프: -10
    │   = 100 + 20 + 30 - 10 = 140
    │
    ├─ Multiply Modifiers (곱하기)
    │   ├─ 거인화 물약: ×1.5
    │   └─ 약화 저주: ×0.8
    │   = 140 × 1.5 × 0.8 = 168
    │
    └─ Override Modifiers (덮어쓰기)
        └─ 무적 상태: = 999999
        = CurrentValue: 999999
```

- "Add -> Multiply -> Override" 규칙을 따름


#### Ability - 실행 가능한 행동

```
class UGameplayAbility
{
    virtual void ActivateAbility(...) override; // 실제 스킬 로직
};
```

```
Input: 플레이어가 Q키 누름
  │
  ▼
┌─────────────────┐
│ TryActivate     │ ← ASC가 자동 호출
│ "Q 스킬 써줘"    │
└─────┬───────────┘
      │
      ▼
┌─────────────────┐     ┌──────────────┐
│ CanActivate?    │────▶│ 실행 불가!   │
│ - 쿨다운 체크   │ NO  │ "아직 3초 남음"│
│ - 자원 체크     │     └──────────────┘
│ - 상태 체크     │
└─────┬───────────┘
      │ YES
      ▼
┌─────────────────┐
│ CommitAbility   │
│ - 마나 30 소모  │
│ - 쿨다운 시작   │
└─────┬───────────┘
      │
      ▼
┌─────────────────┐
│ ActivateAbility │ ← 실제 스킬 로직
│ - 이펙트 생성   │
│ - 데미지 적용   │
│ - 애니메이션    │
└─────┬───────────┘
      │
      ▼
┌─────────────────┐
│ EndAbility      │
│ - 정리 작업     │
│ - 메모리 해제   │
└─────────────────┘
```

- Ability 생명주기
	1. CanActivate : 실행 가능한가?
	2. Commit : 자원 소모, 쿨다운 적용
	3. Activate : 실제 스킬 효과 실행
	4. End : 스킬 종료, 정리 작업

- Ability 종류별 예시
	- 간단한 Ability - 즉시 실행
		- 점프 스킬
	- 복잡한 Ability -  지속 실행
		- 채널링 힐링 (3초간 지속, 이동 금지)
	- 조건부 Ability
		- 반격 스킬 (공격받을 때만 활성화, 5초 내에만 사용 가능)


#### Effect - 실제 변환

- 3가지 타입

|타입|지속시간|용도|예시|
|---|---|---|---|
|**Instant**|없음|즉시 적용 후 사라짐|데미지, 힐링|
|**Duration**|설정값|일정 시간 지속|독, 버프|
|**Infinite**|무한|수동 제거 시까지|장비 효과|

#### 4가지 요소의 협력 과정

```
플레이어 입력 → ASC → Ability → Effect → AttributeSet → UI 업데이트
```

- 힐링 포션 사용 예시
	1. 플레이어가 R키를 누름
	2. ASC가 "힐링 Ability 실행 가능한가?" 판단
	3. Ability가 "마나 30 소모하고 힐링 Effect 적용"
	4. Effect가 "Health + 50" 적용
	5. AttributeSet에서 Health 값 변경
	6. UI에 체력바 업데이트


#### 전체 코드

- 플러그인 활성화
	1. Edit -> Plugins
	2. "Gameplay Abilities" 검색
	3. 체크박스 활성화
	4. 엔진 재시작

- Build.cs 설정

```
PublicDependencyModuleNames.AddRange(new string[]
{
    "Core", "CoreUObject", "Engine", "InputCore",
    "GameplayAbilities",      // 추가!
    "GameplayTags",           // 추가!
    "GameplayTasks"           // 추가!
});
```

- GameplayAbilities : ASC와 Ability의 핵심
- GameplayTags : Effect를 구분하고 관리하는 라벨 시스템
- GameplayTasks : Ability가 시간이 걸리는 작업을 할 때 필요


#### GASCharacter.h

```
#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "AbilitySystemInterface.h"
#include "AbilitySystemComponent.h"

#include "GASCharacter.generated.h"

class UMyAttributeSet;

UCLASS()
class GASDEMO_API AGASCharacter : public ACharacter, public IAbilitySystemInterface
{
    GENERATED_BODY()

public:
    AGASCharacter();

    // IAbilitySystemInterface
    virtual UAbilitySystemComponent* GetAbilitySystemComponent() const override;

protected:
    // GAS 핵심 컴포넌트들
    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS")
    class UAbilitySystemComponent* AbilitySystemComponent;

    UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "GAS")
    class UMyAttributeSet* AttributeSet;

    // Ability 설정
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GAS")
    TArray<TSubclassOf<UGameplayAbility>> StartupAbilities;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "GAS")
    TSubclassOf<UGameplayAbility> DashAbilityClass;

    virtual void BeginPlay() override;
    virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;

    // Input 함수들
    UFUNCTION()
    void InputDash();

    UFUNCTION(BlueprintCallable, Category = "GAS")
    void PrintDebugInfo();

private:
    // 기본 이동 함수들
    void MoveForward(float Value);
    void MoveRight(float Value);
};

```


#### GASCharacter.cpp

```
#include "GASCharacter.h"
#include "MyAttributeSet.h"
#include "Engine/Engine.h"

AGASCharacter::AGASCharacter()
{
    PrimaryActorTick.bCanEverTick = false;

    // ASC 생성
    AbilitySystemComponent = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT("AbilitySystemComp"));

    // AttributeSet 생성
    AttributeSet = CreateDefaultSubobject<UMyAttributeSet>(TEXT("AttributeSet"));
}

UAbilitySystemComponent* AGASCharacter::GetAbilitySystemComponent() const
{
    return AbilitySystemComponent;
}

void AGASCharacter::BeginPlay()
{
    Super::BeginPlay();

    if (AbilitySystemComponent)
    {
        // GAS 초기화 - 가장 중요!
        AbilitySystemComponent->InitAbilityActorInfo(this, this);

        // 시작 Ability들 부여
        for (const auto& AbilityClass : StartupAbilities)
        {
            if (AbilityClass)
            {
                AbilitySystemComponent->
                GiveAbility(FGameplayAbilitySpec(AbilityClass, 1, 0, this));
                
                UE_LOG(LogTemp, Log, TEXT("Gave ability: %s"), *AbilityClass->GetName());
            }
        }

        UE_LOG(LogTemp, Warning, TEXT("GAS Initialized!"));
    }
}

void AGASCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)
{
    Super::SetupPlayerInputComponent(PlayerInputComponent);

    // 기본 이동
    PlayerInputComponent->BindAxis("Move Forward / Backward", this, &AGASCharacter::MoveForward);
    PlayerInputComponent->BindAxis("Move Right / Left", this, &AGASCharacter::MoveRight);
    PlayerInputComponent->BindAxis("Turn Right / Left Mouse", this, &APawn::AddControllerYawInput);
    PlayerInputComponent->BindAxis("Look Up / Down Mouse", this, &APawn::AddControllerPitchInput);

    // Jump
    PlayerInputComponent->BindAction("Jump", IE_Pressed, this, &ACharacter::Jump);
    PlayerInputComponent->BindAction("Jump", IE_Released, this, &ACharacter::StopJumping);

    // Dash
    PlayerInputComponent->BindAction("Dash", IE_Pressed, this, &AGASCharacter::InputDash);
}

void AGASCharacter::InputDash()
{
    if (AbilitySystemComponent && DashAbilityClass)
    {
        bool bSuccess = AbilitySystemComponent->TryActivateAbilityByClass(DashAbilityClass);
        UE_LOG(LogTemp, Log, TEXT("Dash result: %s"), bSuccess ? TEXT("Success") : TEXT("Failed"));
    }
}

void AGASCharacter::PrintDebugInfo()
{
    if (!AttributeSet)
    {
        UE_LOG(LogTemp, Error, TEXT("No AttributeSet"));
        return;
    }

    float Health = AttributeSet->GetHealth();
    float MaxHealth = AttributeSet->GetMaxHealth();
    float Mana = AttributeSet->GetMana();
    float Stamina = AttributeSet->GetStamina();

    FString DebugInfo = FString::Printf(TEXT("Health: %.0f/%.0f, Mana: %.0f, Stamina: %.0f"),
                                      Health, MaxHealth, Mana, Stamina);

    if (GEngine)
    {
        GEngine->AddOnScreenDebugMessage(-1, 3.0f, FColor::Green, DebugInfo);
    }
    UE_LOG(LogTemp, Warning, TEXT("%s"), *DebugInfo);
}

// 기본 이동 함수들
void AGASCharacter::MoveForward(float Value)
{
    if (Controller && Value != 0.0f)
    {
        const FRotator Rotation = Controller->GetControlRotation();
        const FRotator YawRotation(0, Rotation.Yaw, 0);
        const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
        AddMovementInput(Direction, Value);
    }
}

void AGASCharacter::MoveRight(float Value)
{
    if (Controller && Value != 0.0f)
    {
        const FRotator Rotation = Controller->GetControlRotation();
        const FRotator YawRotation(0, Rotation.Yaw, 0);
        const FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);
        AddMovementInput(Direction, Value);
    }
}

```


#### MyAttributeSet.h

```
#pragma once

#include "CoreMinimal.h"
#include "AttributeSet.h"
#include "AbilitySystemComponent.h"

#include "MyAttributeSet.generated.h"

// 매크로 - Getter/Setter 자동 생성
#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
    GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
    GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)

UCLASS()
class GASDEMO_API UMyAttributeSet : public UAttributeSet
{
    GENERATED_BODY()

public:
    UMyAttributeSet();

    // Health
    UPROPERTY(BlueprintReadOnly, Category = "Health", ReplicatedUsing = OnRep_Health)
    FGameplayAttributeData Health;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, Health)

    UPROPERTY(BlueprintReadOnly, Category = "Health", ReplicatedUsing = OnRep_MaxHealth)
    FGameplayAttributeData MaxHealth;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, MaxHealth)

    // Mana
    UPROPERTY(BlueprintReadOnly, Category = "Mana", ReplicatedUsing = OnRep_Mana)
    FGameplayAttributeData Mana;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, Mana)

    UPROPERTY(BlueprintReadOnly, Category = "Mana", ReplicatedUsing = OnRep_MaxMana)
    FGameplayAttributeData MaxMana;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, MaxMana)

    // Stamina
    UPROPERTY(BlueprintReadOnly, Category = "Stamina", ReplicatedUsing = OnRep_Stamina)
    FGameplayAttributeData Stamina;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, Stamina)

    UPROPERTY(BlueprintReadOnly, Category = "Stamina", ReplicatedUsing = OnRep_MaxStamina)
    FGameplayAttributeData MaxStamina;
    ATTRIBUTE_ACCESSORS(UMyAttributeSet, MaxStamina)

protected:
    virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;

    UFUNCTION()
    virtual void OnRep_Health(const FGameplayAttributeData& OldHealth);

    UFUNCTION()
    virtual void OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth);

    UFUNCTION()
    virtual void OnRep_Mana(const FGameplayAttributeData& OldMana);

    UFUNCTION()
    virtual void OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana);

    UFUNCTION()
    virtual void OnRep_Stamina(const FGameplayAttributeData& OldStamina);

    UFUNCTION()
    virtual void OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina);
};

```


#### MyAttributeSet.cpp

```
#include "MyAttributeSet.h"
#include "Net/UnrealNetwork.h"

UMyAttributeSet::UMyAttributeSet()
{
    // 기본값 설정
    InitHealth(100.0f);
    InitMaxHealth(100.0f);
    InitMana(50.0f);
    InitMaxMana(50.0f);
    InitStamina(100.0f);
    InitMaxStamina(100.0f);
}

void UMyAttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    Super::GetLifetimeReplicatedProps(OutLifetimeProps);

    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Health, COND_None, REPNOTIFY_Alwways);
    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);
    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Mana, COND_None, REPNOTIFY_Always);
    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, MaxMana, COND_None, REPNOTIFY_Always);
    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, Stamina, COND_None, REPNOTIFY_Always);
    DOREPLIFETIME_CONDITION_NOTIFY(UMyAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always);
}

void UMyAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Health, OldHealth);
}

void UMyAttributeSet::OnRep_MaxHealth(const FGameplayAttributeData& OldMaxHealth)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, MaxHealth, OldMaxHealth);
}

void UMyAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Mana, OldMana);
}

void UMyAttributeSet::OnRep_MaxMana(const FGameplayAttributeData& OldMaxMana)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, MaxMana, OldMaxMana);
}

void UMyAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, Stamina, OldStamina);
}

void UMyAttributeSet::OnRep_MaxStamina(const FGameplayAttributeData& OldMaxStamina)
{
    GAMEPLAYATTRIBUTE_REPNOTIFY(UMyAttributeSet, MaxStamina, OldMaxStamina);
}

```


#### DashAbility.h

```
#pragma once

#include "CoreMinimal.h"
#include "Abilities/GameplayAbility.h"

#include "DashAbility.generated.h"

UCLASS()
class GASDEMO_API UDashAbility : public UGameplayAbility
{
    GENERATED_BODY()

public:
    UDashAbility();

protected:
    // 대시 설정값들
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Dash")
    float DashDistance = 1000.0f;

    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Dash")
    float DashDuration = 0.2f;

    // 실제 스킬 로직
    virtual void ActivateAbility(
        const FGameplayAbilitySpecHandle Handle,
        const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo,
        const FGameplayEventData* TriggerEventData
    ) override;

    virtual void EndAbility(
        const FGameplayAbilitySpecHandle Handle,
        const FGameplayAbilityActorInfo* ActorInfo,
        const FGameplayAbilityActivationInfo ActivationInfo,
        bool bReplicateEndAbility,
        bool bWasCancelled
    ) override;

private:
    UFUNCTION()
    void OnDashComplete();

    FTimerHandle DashTimerHandle;

    UPROPERTY()
    ACharacter* DashingCharacter;
};

```


#### DashAbility.cpp

```
#include "DashAbility.h"
#include "GameFramework/Character.h"
#include "Engine/Engine.h"

UDashAbility::UDashAbility()
{
		// NonInstanced, InstancedPerActor, InstancedPerExecution
    InstancingPolicy = EGameplayAbilityInstancingPolicy::InstancedPerActor;
    DashingCharacter = nullptr;
}

void UDashAbility::ActivateAbility(
    const FGameplayAbilitySpecHandle Handle,
    const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo,
    const FGameplayEventData* TriggerEventData)
{
    // Cost와 Cooldown 체크 (현재는 둘 다 없음)
    if (!CommitAbility(Handle, ActorInfo, ActivationInfo))
    {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }

    // 캐릭터 가져오기
    DashingCharacter = Cast<ACharacter>(ActorInfo->AvatarActor.Get());
    if (!DashingCharacter)
    {
        EndAbility(Handle, ActorInfo, ActivationInfo, true, false);
        return;
    }

    UE_LOG(LogTemp, Log, TEXT("Dash Ability Activated!"));

    // 대시 실행 - 앞으로 발사
    FVector ForwardVector = DashingCharacter->GetActorForwardVector();
    FVector DashVelocity = ForwardVector * DashDistance;
    DashingCharacter->LaunchCharacter(DashVelocity, true, true);

    // 일정 시간 후 종료
    FTimerDelegate TimerDelegate;
    TimerDelegate.BindUFunction(this, FName("OnDashComplete"));

    DashingCharacter->GetWorldTimerManager().SetTimer(
        DashTimerHandle,
        TimerDelegate,
        DashDuration,
        false
    );
}

void UDashAbility::OnDashComplete()
{
    UE_LOG(LogTemp, Log, TEXT("Dash completed"));
    EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true, false);
}

void UDashAbility::EndAbility(
    const FGameplayAbilitySpecHandle Handle,
    const FGameplayAbilityActorInfo* ActorInfo,
    const FGameplayAbilityActivationInfo ActivationInfo,
    bool bReplicateEndAbility,
    bool bWasCancelled)
{
    // 정리 작업
    if (DashingCharacter)
    {
        DashingCharacter->GetWorldTimerManager().ClearTimer(DashTimerHandle);
    }

    DashingCharacter = nullptr;

    UE_LOG(LogTemp, Log, TEXT("Dash Ability Ended"));

    Super::EndAbility(Handle, ActorInfo, ActivationInfo, bReplicateEndAbility, bWasCancelled);
}
```


#### 전체 시스템 동작 흐름

- 1단계 : 입력 처리

```
플레이어: [Space Bar 누름]
    ↓
InputComponent: "Dash" Action 감지
    ↓
AGASCharacter::InputDash() 호출
    ↓
AbilitySystemComponent->TryActivateAbilityByClass(DashAbilityClass)
```

- 2단계 : ASC의 판단

```
ASC 내부 처리:
1. "DashAbilityClass로 등록된 AbilitySpec이 있나?"
   → StartupAbilities에서 찾기 ✓

2. "현재 활성화 가능한가?"
   → CanActivate 체크 ✓

3. "다른 스킬이 실행 중인가?"
   → 충돌 체크 ✓

결과: "실행 가능! DashAbility.ActivateAbility() 호출!"
```

- 3단계 : Ability 실행

```
UDashAbility::ActivateAbility() {

    // CommitAbility 체크
    if (!CommitAbility(...)) {
        // Cost나 Cooldown 문제시 여기서 종료
        EndAbility(...);
        return;
    }

    // 실제 대시 실행
    DashingCharacter->LaunchCharacter(...);

    // 타이머 시작 (0.2초 후 OnDashComplete 호출)
    SetTimer(...);
}
```

- 4단계 : 타이머 완료

```
0.2초 후...

UDashAbility::OnDashComplete() {
    UE_LOG(LogTemp, Log, TEXT("Dash completed"));
    EndAbility(...);  // 스킬 종료
}

UDashAbility::EndAbility() {
    // 정리 작업
    ClearTimer(...);
    DashingCharacter = nullptr;

    // ASC에 "스킬 끝났어!" 알림
    Super::EndAbility(...);
}
```

- 5단계 : ASC 정리

```
ASC 내부 처리
1. "DashAbility가 끝났네"
2. "AbilitySpec 상태를 비활성으로 변경"
3. "다른 스킬들 사용 가능하게 변경"
4. "필요시 델리게이트 브로드캐스트"

결과: 시스템이 다음 스킬 사용 준비 완료
```